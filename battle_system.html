<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æˆ°é¬¥ç³»çµ±</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
            <style>
            /* æ”»æ“Šå’Œå—æ“Šå‹•ç•« */
            @keyframes pulse {
                0% { transform: scale(1); }
                50% { transform: scale(1.05); }
                100% { transform: scale(1); }
            }
            
            @keyframes shake {
                0%, 100% { transform: translateX(0); }
                25% { transform: translateX(-2px); }
                75% { transform: translateX(2px); }
            }
            
            /* æ”»æ“Šç‹€æ…‹çš„å¡ç‰Œæ¨£å¼ */
            .enemy-card.attacking,
            .player-card.attacking {
                box-shadow: 0 0 15px #ff6b6b;
                border: 2px solid #ff6b6b;
                transform: scale(1.05);
                transition: all 0.3s ease;
            }
            
            /* å—æ“Šç‹€æ…‹çš„å¡ç‰Œæ¨£å¼ */
            .enemy-card.being-attacked,
            .player-card.being-attacked {
                box-shadow: 0 0 15px #ff0000;
                border: 2px solid #ff0000;
                animation: shake 0.3s infinite;
            }
        :root {
            --glow-cyan: #00ffff;
            --glow-magenta: #ff00ff;
            --glow-yellow: #ffff00;
            --dark-blue: #0a1428;
            --medium-blue: #1a2a4a;
            --light-blue: #2a4a8a;
        }

        * {
            box-sizing: border-box;
        }

        body, html {
            width: 100vw;
            height: 100vh;
            margin: 0;
            padding: 0;
            font-family: 'Orbitron', sans-serif;
            background: linear-gradient(135deg, #0a1428 0%, #1a2a4a 50%, #0a1428 100%);
            color: #fff;
            overflow: hidden;
        }

        /* å‹åˆ©å‹•ç•« */
        @keyframes victoryPulse {
            0% { opacity: 0; transform: scale(0.8); }
            50% { opacity: 1; transform: scale(1.1); }
            100% { opacity: 1; transform: scale(1); }
        }

        @keyframes victoryBounce {
            0% { transform: scale(0.3); opacity: 0; }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); opacity: 1; }
        }

        @keyframes victoryFadeIn {
            0% { opacity: 0; transform: translateY(20px); }
            100% { opacity: 1; transform: translateY(0); }
        }

        /* å¤±æ•—å‹•ç•« */
        @keyframes defeatPulse {
            0% { opacity: 0; transform: scale(0.8); }
            50% { opacity: 1; transform: scale(1.05); }
            100% { opacity: 1; transform: scale(1); }
        }

        @keyframes defeatShake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translateX(5px); }
        }

        @keyframes defeatFadeIn {
            0% { opacity: 0; transform: translateY(20px); }
            100% { opacity: 1; transform: translateY(0); }
        }









        .player-card {
            background: rgba(0, 255, 0, 0.2);
            border-color: #44ff44;
        }

        .card-media {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 6px;
        }
        .card-media[is-video] {
            pointer-events: none;
        }











        /* ç·¨è¼¯éšŠä¼ */
        .team-panel {
            background: rgba(10, 20, 40, 0.8);
            border: 2px solid var(--glow-yellow);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 0 20px rgba(255, 255, 0, 0.2);
            min-height: 320px;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            overflow: visible;
        }

        .team-panel h3 {
            margin: 0 0 20px 0;
            color: var(--glow-yellow);
            text-align: center;
        }

        .team-slots {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 20px;
            margin-bottom: 20px;
        }

        .team-slot {
            width: 100px;
            height: 140px;
            background: rgba(255, 255, 0, 0.1);
            border: 2px dashed var(--glow-yellow);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .team-slot:hover {
            background: rgba(255, 255, 0, 0.2);
            border-color: #ffff00;
        }

        .team-slot.filled {
            border-style: solid;
            background: rgba(255, 255, 0, 0.3);
        }

        .team-slot .card-media {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 6px;
        }

        .team-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
            background: rgba(255,255,0,0.08);
            border-radius: 8px;
            padding: 8px 4px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 4px;
            background: rgba(255, 255, 0, 0.13);
            border-radius: 5px;
            font-size: 0.92rem;
            font-weight: bold;
            color: #fffbe0;
        }
        .stat-label {
            color: #ffe066;
            font-size: 0.98em;
            letter-spacing: 0.5px;
        }
        .stat-value {
            color: #fff;
            font-size: 1em;
            font-weight: bold;
            text-shadow: 0 0 3px #ffe06699;
        }

        /* å¡ç‰‡é¸æ“‡å€ */
        .card-library {
            background: rgba(10, 20, 40, 0.8);
            border: 2px solid var(--glow-cyan);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
            overflow-y: auto;
        }

        .card-library h3 {
            margin: 0 0 20px 0;
            color: var(--glow-cyan);
            text-align: center;
        }

        .card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 15px;
            max-height: 200px;
            overflow-y: auto;
        }

        .card {
            width: 80px;
            height: 110px;
            background: rgba(0, 255, 255, 0.1);
            border: 2px solid var(--glow-cyan);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .card.ssr {
            background: rgba(255, 215, 0, 0.15);
            border-color: #ffd700; /* é»ƒè‰² */
            box-shadow: 0 0 8px rgba(255, 215, 0, 0.4);
        }

        .card.a {
            background: rgba(78, 205, 255, 0.15);
            border-color: #2196f3; /* è—è‰² */
            box-shadow: 0 0 6px rgba(33, 150, 243, 0.3);
        }

        .card.r {
            background: rgba(156, 39, 176, 0.15);
            border-color: #9c27b0; /* ç´«è‰² */
            box-shadow: 0 0 4px rgba(156, 39, 176, 0.2);
        }

        .card:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 255, 255, 0.4);
        }

        .card.ssr:hover {
            box-shadow: 0 5px 15px rgba(255, 215, 0, 0.6);
        }

        .card.a:hover {
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.5);
        }

        .card.r:hover {
            box-shadow: 0 5px 15px rgba(78, 205, 196, 0.4);
        }

        .card.selected {
            background: rgba(0, 255, 255, 0.3);
            border-color: #ffff00;
        }

        .card.selected::after {
            content: "å·²é¸å…¥éšŠä¼";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 0, 0.8);
            color: #000;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: bold;
        }

        .card.used {
            opacity: 0.5;
            cursor: not-allowed;
            filter: grayscale(1);
        }

        .card.used::after {
            content: "å·²ä½¿ç”¨";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.7rem;
        }



        /* æ‹–æ”¾æç¤º */
        .team-slot.drag-over {
            outline: 2px dashed #00ffff;
            background: rgba(0,255,255,0.2);
        }
        .card.dragging {
            opacity: 0.6;
            box-shadow: 0 0 16px #00ffff;
        }
        .player-card.ssr, .enemy-card.ssr {
            border-color: #ffd700 !important;
        }
        .player-card.a, .enemy-card.a {
            border-color: #2196f3 !important;
        }
        .player-card.r, .enemy-card.r {
            border-color: #9c27b0 !important;
        }

        /* æ”¾å¤§æˆ°é¬¥å€å’Œæ»‘æ¡¿æ¨£å¼ */
        .main-container {
            display: grid;
            grid-template-columns: 1fr 350px;
            grid-template-rows: 1fr 320px;
            width: 100vw;
            height: 100vh;
            gap: 20px;
            padding: 20px;
            overflow: auto;
        }

        /* æˆ°é¬¥å€é€²ä¸€æ­¥æ”¾å¤§ */
        .battle-area {
            grid-column: 1;
            grid-row: 1;
            background: rgba(10, 20, 40, 0.8);
            border: 2px solid var(--glow-magenta);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 0 20px rgba(162, 89, 255, 0.3);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            overflow-x: hidden;
            min-height: 600px;
        }

        .battle-field {
            flex: 1;
            background: linear-gradient(180deg, rgba(0, 0, 0, 0.5) 0%, rgba(20, 40, 80, 0.3) 100%);
            border-radius: 12px;
            position: relative;
            border: 1px solid rgba(162, 89, 255, 0.3);
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 60px 40px;
            min-height: 500px;
        }

        .enemy-area, .player-area {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 30px;
            flex-wrap: wrap;
            min-height: 180px;
        }

        .enemy-card, .player-card {
            width: 140px;
            height: 190px;
            background: rgba(255, 0, 0, 0.2);
            border: 2px solid #ff4444;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin: 0;
            flex-shrink: 0;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .player-card {
            background: rgba(0, 255, 0, 0.2);
            border-color: #44ff44;
        }

        /* æˆ°é¬¥æ—¥èªŒæ”¾å¤§ */
        .battle-log {
            grid-column: 2;
            grid-row: 1;
            background: rgba(0, 0, 0, 0.85);
            border: 2px solid var(--glow-cyan);
            border-radius: 15px;
            padding: 25px;
            font-size: 1rem;
            overflow-y: auto;
            color: #fff;
            box-shadow: 0 0 12px #00ffff33;
            min-height: 600px;
        }

        /* ä¸‹åŠéƒ¨å€åŸŸèª¿æ•´ */
        .bottom-area {
            grid-column: 1 / span 2;
            grid-row: 2;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            min-height: 320px;
        }

        /* è‡ªå®šç¾©æ»¾å‹•æ¢ */
        ::-webkit-scrollbar {
            width: 12px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--glow-cyan);
            border-radius: 6px;
            border: 2px solid rgba(0, 0, 0, 0.2);
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #00cccc;
        }

        /* æˆ°é¬¥æ§åˆ¶æŒ‰éˆ• */
        .battle-controls {
            margin-top: 15px;
            text-align: center;
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .battle-btn {
            padding: 12px 24px;
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            font-size: 1rem;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(78, 205, 196, 0.3);
            min-width: 140px;
            flex: 0 1 auto;
        }

        .battle-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 255, 255, 0.4);
        }

        .battle-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* æ—¥èªŒæ¢ç›®æ¨£å¼ */
        .log-entry {
            margin-bottom: 10px;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 0.9rem;
            line-height: 1.5;
        }

        .log-entry.system {
            background: rgba(0, 255, 255, 0.1);
            border-left: 4px solid #00ffff;
        }

        .log-entry.player {
            background: rgba(0, 255, 0, 0.1);
            border-left: 4px solid #00ff00;
        }

        .log-entry.enemy {
            background: rgba(255, 0, 0, 0.1);
            border-left: 4px solid #ff0000;
        }

        .log-entry.damage {
            background: rgba(255, 165, 0, 0.1);
            border-left: 4px solid #ffa500;
        }

        /* éŸ¿æ‡‰å¼è¨­è¨ˆ */
        @media (max-width: 1200px) {
            .main-container {
                grid-template-columns: 1fr 300px;
                grid-template-rows: 1fr 280px;
            }
            
            .battle-area {
                padding: 25px;
                min-height: 550px;
            }
            
            .battle-field {
                padding: 50px 25px;
                min-height: 450px;
            }
            
            .enemy-card, .player-card {
                width: 120px;
                height: 160px;
            }
            
            .team-panel, .card-library {
                max-height: 280px;
            }
        }
        
        /* é¸ä¸­å¡ç‰‡æ¨£å¼ */
        .card.selected {
            border: 2px solid #ffd700 !important;
            box-shadow: 0 0 10px #ffd700 !important;
            transform: scale(1.05);
        }

        @media (max-width: 768px) {
            .main-container {
                grid-template-columns: 1fr;
                grid-template-rows: 1fr 1fr 280px;
                gap: 15px;
                padding: 15px;
            }
            
            .battle-area {
                min-height: 500px;
            }
            
            .battle-field {
                padding: 40px 20px;
                min-height: 400px;
            }
            
            .enemy-card, .player-card {
                width: 100px;
                height: 140px;
            }
            
            .battle-log {
                grid-column: 1;
                grid-row: 2;
                min-height: 350px;
            }
            
            .bottom-area {
                grid-column: 1;
                grid-row: 3;
                grid-template-columns: 1fr;
                gap: 15px;
                min-height: 280px;
            }
            
            .team-panel, .card-library {
                max-height: 250px;
            }
        }

        /* éšŠä¼é¢æ¿å’Œå¡ç‰‡åº«æ¨£å¼ */
        .team-panel, .card-library {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid var(--glow-magenta);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 0 15px rgba(162, 89, 255, 0.3);
            backdrop-filter: blur(10px);
            overflow-y: auto;
            max-height: 320px;
        }

        .team-panel h3, .card-library h3 {
            color: var(--glow-magenta);
            font-size: 1.3rem;
            margin-bottom: 15px;
            text-align: center;
            text-shadow: 0 0 10px var(--glow-magenta);
        }

        .team-slots {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-bottom: 20px;
            max-height: 200px;
            overflow-y: auto;
        }

        .team-slot {
            height: 140px;
            border: 2px dashed rgba(162, 89, 255, 0.5);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(162, 89, 255, 0.1);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            min-height: 140px;
        }

        .team-slot.drag-over {
            border-color: var(--glow-magenta);
            background: rgba(162, 89, 255, 0.2);
            transform: scale(1.05);
        }

        .team-slot.filled {
            border-style: solid;
            border-color: var(--glow-magenta);
        }

        .card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(110px, 1fr));
            gap: 15px;
            max-height: 250px;
            overflow-y: auto;
            padding: 15px;
        }

        .card {
            width: 110px;
            height: 150px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            position: relative;
            cursor: pointer;
            transition: all 0.3s ease;
            overflow: hidden;
        }

        .card:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 255, 255, 0.3);
        }

        .card.selected {
            border-color: var(--glow-cyan);
            box-shadow: 0 0 10px var(--glow-cyan);
        }

        .card.used {
            opacity: 0.5;
            filter: grayscale(0.7);
        }

        .card-media {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .team-stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-top: 15px;
            max-height: 120px;
            overflow-y: auto;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            font-size: 0.9rem;
        }

        .stat-label {
            color: #ccc;
        }

        .stat-value {
            color: var(--glow-cyan);
            font-weight: bold;
        }

        /* æˆ°é¬¥å‹•ç•«æ•ˆæœ */
        @keyframes damageFloat {
            0% {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
            25% {
                transform: translateY(-15px) scale(1.3);
                opacity: 1;
            }
            50% {
                transform: translateY(-30px) scale(1.1);
                opacity: 0.8;
            }
            75% {
                transform: translateY(-45px) scale(0.9);
                opacity: 0.5;
            }
            100% {
                transform: translateY(-60px) scale(0.7);
                opacity: 0;
            }
        }

        @keyframes attackGlow {
            0% { box-shadow: 0 0 5px #ff6b6b; }
            50% { box-shadow: 0 0 20px #ff6b6b, 0 0 30px #ff6b6b; }
            100% { box-shadow: 0 0 5px #ff6b6b; }
        }

        @keyframes skillGlow {
            0% { box-shadow: 0 0 5px #ffd700; }
            50% { box-shadow: 0 0 25px #ffd700, 0 0 40px #ffd700; }
            100% { box-shadow: 0 0 5px #ffd700; }
        }

        @keyframes defeatShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        .battle-card {
            transition: all 0.3s ease;
        }

        .battle-card.attacking {
            animation: attackGlow 0.8s ease-in-out;
        }

        .battle-card.skill-attacking {
            animation: skillGlow 1.2s ease-in-out;
        }

        .battle-card.defeated {
            animation: defeatShake 0.5s ease-in-out;
        }

        .damage-number {
            position: absolute;
            font-weight: bold;
            font-size: 1.5rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8), 0 0 8px rgba(255,255,255,0.5);
            z-index: 1000;
            pointer-events: none;
            background: rgba(0,0,0,0.3);
            padding: 2px 6px;
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.3);
        }

        .damage-number.normal {
            color: #ff6b6b;
            animation: damageFloat 1s ease-out forwards;
        }

        .damage-number.skill {
            color: #ffd700;
            animation: damageFloat 1.2s ease-out forwards;
        }

        .damage-number.critical {
            color: #ff4757;
            font-size: 1.4rem;
            animation: damageFloat 1.5s ease-out forwards;
        }
    </style>
</head>
<body>
    <!-- å¡ç‰‡æ”¾å¤§é è¦½ Modal -->
    <div id="card-preview-modal" style="display:none; position:fixed; z-index:9999; left:0; top:0; width:100vw; height:100vh; background:rgba(0,0,0,0.65); align-items:center; justify-content:center;">
        <div id="card-preview-content" style="position:relative; background:rgba(20,30,40,0.98); border-radius:18px; box-shadow:0 0 32px #00ffff99; padding:24px; display:flex; flex-direction:column; align-items:center;">
            <button id="close-card-preview" style="position:absolute; top:8px; right:12px; background:#222; color:#fff; border:none; border-radius:50%; width:32px; height:32px; font-size:1.3rem; cursor:pointer;">Ã—</button>
            <div id="card-preview-media"></div>
            <div id="card-preview-title" style="margin-top:12px; font-size:1.3rem; color:#ffe066; font-weight:bold;"></div>
            <div id="card-preview-stats" style="margin-top:8px; font-size:1.1rem; color:#fff;"></div>
        </div>
    </div>
    

    
    <div class="main-container">
        <!-- æ˜Ÿæ˜Ÿé¡¯ç¤ºå€ -->
        <div style="position: fixed; top: 20px; right: 20px; z-index: 1000; background: rgba(0,0,0,0.8); padding: 10px 15px; border-radius: 10px; border: 2px solid #ffd700; box-shadow: 0 0 10px rgba(255,215,0,0.3);">
            <div style="color: #ffd700; font-weight: bold; font-size: 1.2rem;">
                â­ <span id="totalStarsCount">0</span>
            </div>
        </div>

        <!-- è¿”å›é¦–é æŒ‰éˆ• -->
        <div style="position: fixed; top: 20px; left: 20px; z-index: 1000;">
            <button id="back-to-home" style="background: linear-gradient(45deg, #00ffff, #ff00ff); border: none; border-radius: 10px; padding: 12px 20px; color: #000; font-weight: bold; font-size: 1rem; cursor: pointer; box-shadow: 0 0 15px rgba(0,255,255,0.4); transition: all 0.3s ease;" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 5px 20px rgba(0,255,255,0.6)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 0 15px rgba(0,255,255,0.4)'">
                ğŸ  è¿”å›é¦–é 
            </button>
        </div>

        <!-- æˆ°é¬¥å€ -->
        <div class="battle-area">
            <div class="battle-field">
                <div class="enemy-area" id="enemy-area">
                    <!-- æ•µäººå¡ç‰Œæœƒåœ¨é€™è£¡é¡¯ç¤º -->
                </div>
                <div class="player-area" id="player-area">
                    <!-- ç©å®¶å¡ç‰Œæœƒåœ¨é€™è£¡é¡¯ç¤º -->
                </div>
            </div>
            <div class="battle-controls">
                <button class="battle-btn" id="start-battle">é–‹å§‹æˆ°é¬¥</button>
                <button class="battle-btn" id="manual-battle" style="background: linear-gradient(45deg, #ffd700, #ff6b6b);">æ‰‹å‹•æˆ°é¬¥</button>
                <button class="battle-btn" id="reset-stage" style="background: linear-gradient(45deg, #ffd700, #ffed4e);">é‡ç½®é—œå¡</button>
            </div>
            <!-- æ‰‹å‹•æˆ°é¬¥æ§åˆ¶å€ -->
            <div id="manual-controls" style="display: none; margin-top: 15px; padding: 15px; background: rgba(0,0,0,0.3); border-radius: 10px; border: 1px solid #00ffff;">
                <div style="text-align: center; margin-bottom: 10px; color: #00ffff; font-weight: bold;">æ‰‹å‹•æˆ°é¬¥æ§åˆ¶</div>
                <div id="current-turn-info" style="text-align: center; margin-bottom: 10px; color: #fff;"></div>
                <div id="enemy-selection" style="display: none; margin-bottom: 15px; text-align: center;">
                    <div style="color: #ffd700; font-weight: bold; margin-bottom: 8px;">é¸æ“‡æ”»æ“Šç›®æ¨™ï¼š</div>
                    <div id="enemy-targets" style="display: flex; justify-content: center; gap: 10px; flex-wrap;"></div>
                </div>
                <div id="action-buttons" style="display: flex; justify-content: center; gap: 10px; flex-wrap: wrap;">
                    <button id="attack-btn" class="battle-btn" style="background: linear-gradient(45deg, #ff6b6b, #ff8e8e);">æ”»æ“Š</button>
                    <button id="skill-btn" class="battle-btn" style="background: linear-gradient(45deg, #4ecdc4, #6ee7df);">æŠ€èƒ½</button>
                    <button id="defend-btn" class="battle-btn" style="background: linear-gradient(45deg, #ffd700, #ffed4e);">é˜²ç¦¦</button>
                    <button id="skip-btn" class="battle-btn" style="background: linear-gradient(45deg, #95a5a6, #bdc3c7);">è·³é</button>
                </div>
            </div>
        </div>

        <!-- æˆ°é¬¥æ—¥èªŒ -->
        <div class="battle-log" id="battle-log">
            <div class="log-entry system">æˆ°é¬¥ç³»çµ±å·²æº–å‚™å°±ç·’ï¼</div>
        </div>

        <!-- ä¸‹åŠéƒ¨å€åŸŸ -->
        <div class="bottom-area">
            <!-- ç·¨è¼¯éšŠä¼ -->
            <div class="team-panel">
                <h3>ç·¨è¼¯éšŠä¼</h3>
                <div class="team-slots">
                    <div class="team-slot" data-slot="0">
                        <span>æ‹–æ”¾å¡ç‰Œ</span>
                    </div>
                    <div class="team-slot" data-slot="1">
                        <span>æ‹–æ”¾å¡ç‰Œ</span>
                    </div>
                    <div class="team-slot" data-slot="2">
                        <span>æ‹–æ”¾å¡ç‰Œ</span>
                    </div>
                    <div class="team-slot" data-slot="3">
                        <span>æ‹–æ”¾å¡ç‰Œ</span>
                    </div>
                </div>
                
                <div class="team-stats">
                    <div class="stat-item">
                        <span class="stat-label">ç•¶å‰é—œå¡:</span>
                        <span class="stat-value" id="current-stage">ç¬¬1é—œ</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">ç¸½æ”»æ“ŠåŠ›:</span>
                        <span class="stat-value" id="total-attack">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">ç¸½é˜²ç¦¦åŠ›:</span>
                        <span class="stat-value" id="total-defense">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">ç¸½ç”Ÿå‘½å€¼:</span>
                        <span class="stat-value" id="total-hp">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">éšŠä¼æŠ€èƒ½:</span>
                        <span class="stat-value" id="team-skill">ç„¡</span>
                    </div>
                </div>
            </div>

            <!-- å¡ç‰‡é¸æ“‡å€ -->
            <div class="card-library">
                <h3>å¡ç‰‡é¸æ“‡å€</h3>
                <div style="margin-bottom: 10px; text-align: center;">
    
                                    <span style="color: #4ecdc4; font-size: 0.9rem;">ğŸ“ˆ åªèƒ½é€šéæˆ°é¬¥ç²å¾—ç¶“é©—å€¼è‡ªå‹•å‡ç´š</span>
                </div>
                <div class="card-grid" id="card-grid">
                    <!-- å¡ç‰‡æœƒåœ¨é€™è£¡å‹•æ…‹ç”Ÿæˆ -->
                </div>
            </div>
        </div>
    </div>

    <!-- JavaScript -->
    <script src="js/sound.js"></script>
    <script src="js/soundSystem.js"></script>
    <script src="js/userData.js"></script>
    <script src="js/starRewardSystem.js"></script>
    <script src="js/cardUtils.js"></script>
    <script src="js/vocabData.js"></script>
    <script src="js/cards.js"></script>
    <script src="js/custom_cards.js"></script>
    <script src="js/achievementSystem.js"></script>
    
    <!-- å¦‚æœå¤–éƒ¨å¡ç‰‡æ–‡ä»¶è¼‰å…¥å¤±æ•—ï¼Œä½¿ç”¨é è¨­å¡ç‰‡ -->
    <script>
        // ç¢ºä¿baseCardså­˜åœ¨
        if (typeof baseCards === 'undefined') {
            console.log('å¤–éƒ¨å¡ç‰‡æ–‡ä»¶è¼‰å…¥å¤±æ•—ï¼Œä½¿ç”¨é è¨­å¡ç‰‡');
            window.baseCards = [
                {
                    zh: "å®™æ–¯",
                    en: "Zeus",
                    image: "zeus.html",
                    attack: 200,
                    defense: 150,
                    hp: 300,
                    rarity: "è¶…ç¨€æœ‰",
                    skill: {
                        name: "é›·éœ†è¬éˆ",
                        description: "å°æ‰€æœ‰æ•µäººé€ æˆå¤§é‡å‚·å®³",
                        cooldown: 3
                    }
                },
                {
                    zh: "é˜¿æ³¢ç¾…",
                    en: "Apollo",
                    image: "apollo.html",
                    attack: 180,
                    defense: 120,
                    hp: 250,
                    rarity: "ç¨€æœ‰",
                    skill: {
                        name: "å¤ªé™½ç¥ç®­",
                        description: "å°å–®ä¸€æ•µäººé€ æˆé«˜å‚·å®³",
                        cooldown: 2
                    }
                },
                {
                    zh: "é›…å…¸å¨œ",
                    en: "Athena",
                    image: "athena.html",
                    attack: 160,
                    defense: 180,
                    hp: 280,
                    rarity: "ç¨€æœ‰",
                    skill: {
                        name: "æ™ºæ…§è­·ç›¾",
                        description: "å¤§å¹…æå‡é˜²ç¦¦åŠ›",
                        cooldown: 4
                    }
                },
                {
                    zh: "é˜¿ç‘æ–¯",
                    en: "Ares",
                    image: "ares.html",
                    attack: 220,
                    defense: 100,
                    hp: 200,
                    rarity: "ç¨€æœ‰",
                    skill: {
                        name: "æˆ°çˆ­æ€’å¼",
                        description: "æå‡æ”»æ“ŠåŠ›ä¸¦é€ æˆå‚·å®³",
                        cooldown: 3
                    }
                },
                {
                    zh: "æ³¢å¡å†¬",
                    en: "Poseidon",
                    image: "poseidon.html",
                    attack: 170,
                    defense: 160,
                    hp: 270,
                    rarity: "ç¨€æœ‰",
                    skill: {
                        name: "æµ·å˜¯è¡æ“Š",
                        description: "å°æ•µäººé€ æˆç¯„åœå‚·å®³",
                        cooldown: 3
                    }
                }
            ];
        }
    </script>
    <script>
        // éŠæˆ²ç‹€æ…‹
        // ç²å–ç•¶å‰æ˜Ÿæ˜Ÿæ•¸é‡
        function getCurrentStars() {
            console.log('getCurrentStars è¢«èª¿ç”¨');
            if (typeof StarRewardSystem !== 'undefined') {
                console.log('ä½¿ç”¨ StarRewardSystem');
                return parseInt(localStorage.getItem('totalStars') || '0');
            } else if (typeof LinkageSystem !== 'undefined' && LinkageSystem.stars) {
                console.log('ä½¿ç”¨ LinkageSystem');
                return LinkageSystem.stars.get();
            } else {
                console.log('ä½¿ç”¨ localStorage');
                return parseInt(localStorage.getItem('totalStars') || '0');
            }
        }

        // å¢åŠ æ˜Ÿæ˜Ÿï¼ˆæˆ°é¬¥ç³»çµ±å°ˆç”¨ï¼‰
        function addStarsToBattle(amount) {
            console.log('addStarsToBattle è¢«èª¿ç”¨ï¼Œæ•¸é‡:', amount);
            
            // æª¢æŸ¥æ˜¯å¦å·²ç¶“çµ¦äºˆéæ˜Ÿæ˜Ÿçå‹µ
            if (gameState.starsAdded) {
                console.log('å·²ç¶“çµ¦äºˆéæ˜Ÿæ˜Ÿçå‹µï¼Œè·³é');
                return;
            }
            
            let currentStars = 0;
            
            // å…ˆç²å–ç•¶å‰æ˜Ÿæ˜Ÿæ•¸é‡
            if (typeof StarRewardSystem !== 'undefined') {
                console.log('ä½¿ç”¨ StarRewardSystem');
                currentStars = parseInt(localStorage.getItem('totalStars') || '0');
            } else if (typeof LinkageSystem !== 'undefined' && LinkageSystem.stars) {
                console.log('ä½¿ç”¨ LinkageSystem');
                currentStars = LinkageSystem.stars.get();
            } else {
                console.log('ä½¿ç”¨ localStorage');
                currentStars = parseInt(localStorage.getItem('totalStars') || '0');
            }
            
            // è¨ˆç®—æ–°çš„æ˜Ÿæ˜Ÿæ•¸é‡
            const newStars = currentStars + amount;
            console.log(`æ˜Ÿæ˜Ÿè¨ˆç®—: ${currentStars} + ${amount} = ${newStars}`);
            
            // æ›´æ–°æ˜Ÿæ˜Ÿæ•¸é‡
            if (typeof StarRewardSystem !== 'undefined') {
                localStorage.setItem('totalStars', newStars.toString());
                // å˜—è©¦èª¿ç”¨ StarRewardSystem çš„æ–¹æ³•
                if (typeof StarRewardSystem.addStars === 'function') {
                    StarRewardSystem.addStars(amount);
                }
            } else if (typeof LinkageSystem !== 'undefined' && LinkageSystem.stars) {
                LinkageSystem.stars.set(newStars);
            } else {
                localStorage.setItem('totalStars', newStars.toString());
            }
            
            // æ¨™è¨˜å·²ç¶“çµ¦äºˆæ˜Ÿæ˜Ÿçå‹µ
            gameState.starsAdded = true;
            
            console.log('æ˜Ÿæ˜Ÿæ›´æ–°å®Œæˆï¼Œç•¶å‰æ˜Ÿæ˜Ÿ:', getCurrentStars());
            updateStarsDisplay();
        }

        // æ›´æ–°æ˜Ÿæ˜Ÿé¡¯ç¤º
        function updateStarsDisplay() {
            const starsElement = document.getElementById('totalStarsCount');
            if (starsElement) {
                const currentStars = getCurrentStars();
                starsElement.textContent = currentStars;
                console.log('æ˜Ÿæ˜Ÿé¡¯ç¤ºå·²æ›´æ–°:', currentStars);
            } else {
                console.log('æ‰¾ä¸åˆ°æ˜Ÿæ˜Ÿé¡¯ç¤ºå…ƒç´ ');
            }
        }

        // åˆå§‹åŒ–æ˜Ÿæ˜Ÿé¡¯ç¤º
        function initStarsDisplay() {
            updateStarsDisplay();
            console.log('æ˜Ÿæ˜Ÿé¡¯ç¤ºåˆå§‹åŒ–å®Œæˆï¼Œç•¶å‰æ˜Ÿæ˜Ÿ:', getCurrentStars());
        }

        const gameState = {
            playerTeam: [],
            enemyTeam: [],
            isBattleActive: false,
            currentTurn: 0,
            hasAttacked: false, // æ¨™è¨˜æ˜¯å¦å·²ç¶“æ”»æ“Šé
            starsAdded: false, // æ¨™è¨˜æ˜¯å¦å·²ç¶“çµ¦äºˆæ˜Ÿæ˜Ÿçå‹µ

            selectedCards: new Set() // è¨˜éŒ„å·²é¸å…¥éšŠä¼ä½†æœªä½¿ç”¨çš„å¡ç‰‡
        };

        // ç©å®¶ç‹€æ…‹
        const playerStatus = {
            coins: 1000,
            stars: 50,
            exp: 0,
            stage: 1
        };

        // åˆå§‹åŒ–éŠæˆ²
        function initGame() {
            console.log('initGame é–‹å§‹åŸ·è¡Œ');
            console.log('baseCards æ˜¯å¦å­˜åœ¨:', typeof baseCards !== 'undefined');
            console.log('baseCards é•·åº¦:', typeof baseCards !== 'undefined' ? baseCards.length : 'undefined');
            
            if (typeof baseCards === 'undefined') {
                console.log('ç­‰å¾…å¡ç‰‡è³‡æ–™è¼‰å…¥...');
                setTimeout(initGame, 100);
                return;
            }
            console.log('å¡ç‰‡è³‡æ–™å·²è¼‰å…¥ï¼Œå…±', baseCards.length, 'å¼µå¡ç‰‡');
            
            // æª¢æŸ¥å¡ç‰‡è³‡æ–™æ˜¯å¦æ­£ç¢º
            if (baseCards.length === 0) {
                console.error('å¡ç‰‡è³‡æ–™ç‚ºç©ºï¼');
                addLogEntry('ç³»çµ±', 'âŒ å¡ç‰‡è³‡æ–™è¼‰å…¥å¤±æ•—ï¼');
                return;
            }
            
            // éæ¿¾åªé¡¯ç¤ºå·²è§£é–çš„å¡ç‰‡
            filterUnlockedCards();
            
            // ç‚ºå¡ç‰‡è£œå……ç´ è³ªå±¬æ€§
            enhanceCardsWithStats();
            
            // è¼‰å…¥å¡ç‰Œç­‰ç´šæ•¸æ“š
            loadCardLevels();
            

            createCardGrid();
            setupEventListeners();
            updateTeamStats();
            initStarsDisplay();
            console.log('éŠæˆ²åˆå§‹åŒ–å®Œæˆ');
            addLogEntry('ç³»çµ±', 'éŠæˆ²åˆå§‹åŒ–å®Œæˆï¼');
        }

        // éæ¿¾åªé¡¯ç¤ºå·²è§£é–çš„å¡ç‰‡
        function filterUnlockedCards() {
            console.log('é–‹å§‹éæ¿¾å·²è§£é–çš„å¡ç‰‡...');
            
            // æª¢æŸ¥ LinkageSystem æ˜¯å¦å¯ç”¨
            if (typeof LinkageSystem === 'undefined' || !LinkageSystem.cards) {
                console.warn('LinkageSystem ä¸å¯ç”¨ï¼Œé¡¯ç¤ºæ‰€æœ‰å¡ç‰‡');
                return;
            }
            
            // ç²å–å·²è§£é–çš„å¡ç‰‡
            const ownedCards = LinkageSystem.cards.getOwnedCards();
            console.log('å·²è§£é–å¡ç‰‡æ•¸é‡:', Object.keys(ownedCards).length);
            
            // éæ¿¾ baseCardsï¼Œåªä¿ç•™å·²è§£é–çš„å¡ç‰‡
            const originalLength = baseCards.length;
            const unlockedCards = baseCards.filter(card => {
                const isUnlocked = LinkageSystem.cards.isCardOwned(card.word);
                return isUnlocked;
            });
            
            // æ›´æ–° baseCards ç‚ºå·²è§£é–çš„å¡ç‰‡
            baseCards.length = 0;
            unlockedCards.forEach(card => baseCards.push(card));
            
            console.log(`å¡ç‰‡éæ¿¾å®Œæˆï¼š${originalLength} -> ${baseCards.length} å¼µå·²è§£é–å¡ç‰‡`);
            addLogEntry('ç³»çµ±', `ğŸ“‹ å·²è¼‰å…¥ ${baseCards.length} å¼µå·²è§£é–å¡ç‰‡`);
            
            if (baseCards.length === 0) {
                console.warn('æ²’æœ‰å·²è§£é–çš„å¡ç‰‡ï¼');
                addLogEntry('ç³»çµ±', 'âš ï¸ æ²’æœ‰å·²è§£é–çš„å¡ç‰‡ï¼Œè«‹å…ˆåœ¨å¡ç‰‡æ”¶è—é é¢è§£é–å¡ç‰‡ï¼');
            }
        }

        // è¼‰å…¥ä»Šå¤©è¢«æ‰“æ•—çš„å¡ç‰‡


        // è¼‰å…¥å¡ç‰Œç­‰ç´šå’Œç¶“é©—å€¼æ•¸æ“š
        function loadCardLevels() {
            const savedLevels = localStorage.getItem('cardLevels');
            if (savedLevels) {
                try {
                    const levels = JSON.parse(savedLevels);
                    console.log('è¼‰å…¥çš„ç­‰ç´šæ•¸æ“š:', levels);
                    levels.forEach(levelData => {
                        // å˜—è©¦å¤šç¨®åŒ¹é…æ–¹å¼
                        let card = baseCards.find(c => c.zh === levelData.index);
                        if (!card) {
                            card = baseCards.find(c => c.id === levelData.index);
                        }
                        if (!card) {
                            card = baseCards.find(c => (c.id || c.zh) === levelData.index);
                        }
                        if (card) {
                            card.level = levelData.level;
                            card.exp = levelData.exp || 0;
                            console.log('æˆåŠŸè¼‰å…¥å¡ç‰‡ç­‰ç´š:', card.zh, 'ç­‰ç´š:', card.level, 'ç¶“é©—å€¼:', card.exp);
                        } else {
                            console.log('æ‰¾ä¸åˆ°å°æ‡‰çš„å¡ç‰‡:', levelData.index);
                        }
                    });
                    console.log('å·²è¼‰å…¥å¡ç‰Œç­‰ç´šå’Œç¶“é©—å€¼æ•¸æ“š');
                } catch (error) {
                    console.error('è¼‰å…¥å¡ç‰Œç­‰ç´šæ•¸æ“šå¤±æ•—:', error);
                }
            } else {
                console.log('æ²’æœ‰æ‰¾åˆ°å·²ä¿å­˜çš„å¡ç‰Œç­‰ç´šæ•¸æ“š');
            }
        }

        // è¨ˆç®—å‡ç´šæ‰€éœ€ç¶“é©—å€¼
        function getExpForNextLevel(currentLevel) {
            return Math.floor(100 * Math.pow(1.5, currentLevel - 1));
        }

        // æª¢æŸ¥æ˜¯å¦å¯ä»¥å‡ç´š
        function canLevelUp(card) {
            const currentLevel = card.level || 1;
            const currentExp = card.exp || 0;
            const requiredExp = getExpForNextLevel(currentLevel);
            return currentExp >= requiredExp;
        }

        // è‡ªå‹•å‡ç´šå¡ç‰Œ
        function autoLevelUp(card) {
            const currentLevel = card.level || 1;
            const currentExp = card.exp || 0;
            const requiredExp = getExpForNextLevel(currentLevel);
            
            if (currentExp >= requiredExp) {
                const newLevel = currentLevel + 1;
                const remainingExp = currentExp - requiredExp;
                
                card.level = newLevel;
                card.exp = remainingExp;
                
                // è¨ˆç®—å‡ç´šå¾Œçš„ç´ è³ªå°æ¯”
                const currentLevelBonus = (currentLevel - 1) * 0.2;
                const newLevelBonus = (newLevel - 1) * 0.2;
                const baseAttack = card.attack || 50;
                const baseDefense = card.defense || 30;
                const baseHp = card.hp || 100;
                
                const currentAttack = Math.round(baseAttack * (1 + currentLevelBonus));
                const currentDefense = Math.round(baseDefense * (1 + currentLevelBonus));
                const currentHp = Math.round(baseHp * (1 + currentLevelBonus));
                
                const newAttack = Math.round(baseAttack * (1 + newLevelBonus));
                const newDefense = Math.round(baseDefense * (1 + newLevelBonus));
                const newHp = Math.round(baseHp * (1 + newLevelBonus));
                
                // é¡¯ç¤ºå‡ç´šå°æ¯”Modal
                showLevelUpModal(card, {
                    oldLevel: currentLevel,
                    newLevel: newLevel,
                    oldAttack: currentAttack,
                    newAttack: newAttack,
                    oldDefense: currentDefense,
                    newDefense: newDefense,
                    oldHp: currentHp,
                    newHp: newHp
                });
                
                addLogEntry('system', `ğŸŒŸ ${card.zh} è‡ªå‹•å‡ç´šï¼ç­‰ç´šï¼š${currentLevel} â†’ ${newLevel}`);
                addLogEntry('system', `ğŸ’ª æ”»æ“ŠåŠ›ï¼š${currentAttack} â†’ ${newAttack}`);
                addLogEntry('system', `ğŸ›¡ï¸ é˜²ç¦¦åŠ›ï¼š${currentDefense} â†’ ${newDefense}`);
                addLogEntry('system', `â¤ï¸ è¡€é‡ï¼š${currentHp} â†’ ${newHp}`);
                
                // ä¿å­˜å‡ç´šå¾Œçš„å¡ç‰Œæ•¸æ“š
                const cardLevelsData = baseCards.map(c => ({ 
                    index: c.id || c.zh, 
                    level: c.level || 1,
                    exp: c.exp || 0
                }));
                localStorage.setItem('cardLevels', JSON.stringify(cardLevelsData));
                console.log('ä¿å­˜å‡ç´šå¾Œçš„å¡ç‰Œæ•¸æ“š:', cardLevelsData);
                
                return true;
            }
            return false;
        }

        // ç‚ºå¡ç‰Œæ·»åŠ ç¶“é©—å€¼ï¼ˆåªèƒ½é€šéæˆ°é¬¥ç²å¾—ï¼‰
        function addExpToCard(card, expAmount) {
            console.log('addExpToCard è¢«èª¿ç”¨:', card.zh, 'ç¶“é©—å€¼:', expAmount);
            if (!card.exp) card.exp = 0;
            const oldExp = card.exp;
            card.exp += expAmount;
            console.log('ç¶“é©—å€¼æ›´æ–°:', card.zh, oldExp, '->', card.exp);
            
            const currentLevel = card.level || 1;
            const requiredExp = getExpForNextLevel(currentLevel);
            const expProgress = Math.min(100, Math.round((card.exp / requiredExp) * 100));
            
            addLogEntry('system', `ğŸ“ˆ ${card.zh} ç²å¾— ${expAmount} æˆ°é¬¥ç¶“é©—å€¼ï¼`);
            addLogEntry('system', `ğŸ“Š ç¶“é©—å€¼é€²åº¦ï¼š${card.exp}/${requiredExp} (${expProgress}%)`);
            
            // æª¢æŸ¥æ˜¯å¦å¯ä»¥å‡ç´š
            if (autoLevelUp(card)) {
                // å¦‚æœå‡ç´šäº†ï¼Œå†æ¬¡æª¢æŸ¥æ˜¯å¦å¯ä»¥é€£çºŒå‡ç´š
                while (autoLevelUp(card)) {
                    // é€£çºŒå‡ç´š
                }
            }
            
            // ä¿å­˜ç¶“é©—å€¼æ•¸æ“š
            const cardLevelsData = baseCards.map(c => ({ 
                index: c.id || c.zh, 
                level: c.level || 1,
                exp: c.exp || 0
            }));
            localStorage.setItem('cardLevels', JSON.stringify(cardLevelsData));
            console.log('ä¿å­˜ç¶“é©—å€¼æ•¸æ“š:', cardLevelsData);
        }

        // ç‚ºå¡ç‰‡è£œå……ç´ è³ªå±¬æ€§
        function enhanceCardsWithStats() {
            baseCards.forEach((card, index) => {
                // å¦‚æœå¡ç‰‡æ²’æœ‰ç´ è³ªï¼Œæ ¹æ“šç´¢å¼•ç”Ÿæˆéš¨æ©Ÿä½†å›ºå®šçš„ç´ è³ª
                if (!card.attack || !card.defense || !card.hp) {
                    const seed = index * 7 + 13; // ç°¡å–®çš„éš¨æ©Ÿç¨®å­
                    // æ ¹æ“šç¨€æœ‰åº¦è¨­å®šç´ è³ªç¯„åœ
                    const rarity = card.rarity || getRandomRarity(seed);
                    card.rarity = rarity;
                    let minStat, maxStat;
                    if (rarity === 'è¶…ç¨€æœ‰') {
                        minStat = 180; maxStat = 250; // è¶…ç¨€æœ‰ï¼š180-250
                    } else if (rarity === 'ç¨€æœ‰') {
                        minStat = 50; maxStat = 100;  // ç¨€æœ‰ï¼š50-100ï¼ˆæœ€ä½ï¼‰
                    } else {
                        minStat = 100; maxStat = 160; // æ™®é€šï¼š100-160ï¼ˆä¸­ç­‰ï¼‰
                    }
                    card.attack = card.attack || (minStat + (seed * 3 % (maxStat - minStat + 1)));
                    card.defense = card.defense || (minStat + (seed * 5 % (maxStat - minStat + 1)));
                    card.hp = card.hp || (minStat + (seed * 7 % (maxStat - minStat + 1)));
                    // ç‚ºå¡ç‰‡åŠ å…¥æŠ€èƒ½
                    if (!card.skill) {
                        card.skill = generateSkill(card, seed);
                    }
                }
            });
            console.log('å·²ç‚º', baseCards.length, 'å¼µå¡ç‰‡è£œå……ç´ è³ª');
        }

        // ç”Ÿæˆå¡ç‰‡æŠ€èƒ½
        function generateSkill(card, seed) {
            const skills = [
                { name: 'æ™®é€šæ”»æ“Š', damage: 1.0, cooldown: 0, description: 'åŸºç¤æ”»æ“Š' },
                { name: 'å¼·åŠ›ä¸€æ“Š', damage: 1.5, cooldown: 2, description: 'é€ æˆ1.5å€å‚·å®³' },
                { name: 'é˜²ç¦¦å§¿æ…‹', damage: 0.5, cooldown: 1, description: 'æ”»æ“ŠåŠ›æ¸›åŠä½†å¢åŠ é˜²ç¦¦' },
                { name: 'æš´æ“Š', damage: 2.0, cooldown: 4, description: 'é€ æˆé›™å€å‚·å®³' }
            ];
            const skillIndex = seed % skills.length;
            const baseSkill = skills[skillIndex];
            
            // æ ¹æ“šç¨€æœ‰åº¦èª¿æ•´å†·å»æ™‚é–“
            let adjustedCooldown = baseSkill.cooldown;
            if (card.rarity === 'è¶…ç¨€æœ‰') {
                // SSRå¡ç‰‡å†·å»æ™‚é–“æ¸›åŠï¼ˆæœ€çŸ­ï¼‰
                adjustedCooldown = Math.max(0, Math.floor(baseSkill.cooldown * 0.5));
            } else if (card.rarity === 'ç¨€æœ‰') {
                // Aå¡ç‰‡å†·å»æ™‚é–“ç¨å¾®æ¸›å°‘
                adjustedCooldown = Math.max(0, Math.floor(baseSkill.cooldown * 0.8));
            } else {
                // æ™®é€šå¡ç‰‡ä¿æŒåŸå†·å»æ™‚é–“
                adjustedCooldown = baseSkill.cooldown;
            }
            
            return { 
                ...baseSkill, 
                cooldown: adjustedCooldown,
                currentCooldown: 0 
            };
        }

        // æˆ°é¬¥æ§åˆ¶è®Šæ•¸
        let currentAttacker = 0; // 0=ç©å®¶å›åˆ, 1=æ•µäººå›åˆ
        let currentPlayerIndex = 0;
        let currentEnemyIndex = 0;
        let isManualBattle = false;
        let isAnimating = false; // é˜²æ­¢å‹•ç•«æœŸé–“é‡è¤‡é»æ“Š
        let selectedEnemyIndex = -1; // é¸æ“‡çš„æ•µäººç´¢å¼•
        let isSelectingTarget = false; // æ˜¯å¦æ­£åœ¨é¸æ“‡ç›®æ¨™

        // æ’­æ”¾éŒ¯èª¤éŸ³æ•ˆ
        function playWrongSound() {
            try {
                // å˜—è©¦ä½¿ç”¨ç¾æœ‰çš„éŸ³æ•ˆç³»çµ±
                if (typeof playSound === 'function') {
                    playSound('wrong');
                } else if (typeof SoundSystem !== 'undefined' && SoundSystem.play) {
                    SoundSystem.play('wrong');
                } else {
                    // å‰µå»ºéŸ³æ•ˆå…ƒç´ 
                    const audio = new Audio('sound/wrong.mp3');
                    audio.volume = 0.3;
                    audio.play().catch(e => console.log('éŸ³æ•ˆæ’­æ”¾å¤±æ•—:', e));
                }
            } catch (error) {
                console.log('éŸ³æ•ˆæ’­æ”¾éŒ¯èª¤:', error);
            }
        }

        // æ’­æ”¾æ”»æ“ŠéŸ³æ•ˆ
        function playAttackSound() {
            try {
                if (typeof playSound === 'function') {
                    playSound('click');
                } else if (typeof SoundSystem !== 'undefined' && SoundSystem.play) {
                    SoundSystem.play('click');
                } else {
                    const audio = new Audio('sound/click.mp3');
                    audio.volume = 0.2;
                    audio.play().catch(e => console.log('éŸ³æ•ˆæ’­æ”¾å¤±æ•—:', e));
                }
            } catch (error) {
                console.log('éŸ³æ•ˆæ’­æ”¾éŒ¯èª¤:', error);
            }
        }

        // æ’­æ”¾æŠ€èƒ½éŸ³æ•ˆ
        function playSkillSound() {
            try {
                if (typeof playSound === 'function') {
                    playSound('correct');
                } else if (typeof SoundSystem !== 'undefined' && SoundSystem.play) {
                    SoundSystem.play('correct');
                } else {
                    const audio = new Audio('sound/correct.mp3');
                    audio.volume = 0.3;
                    audio.play().catch(e => console.log('éŸ³æ•ˆæ’­æ”¾å¤±æ•—:', e));
                }
            } catch (error) {
                console.log('éŸ³æ•ˆæ’­æ”¾éŒ¯èª¤:', error);
            }
        }

        // æˆ°é¬¥å‹•ç•«æ•ˆæœ
        function animateAttack(attacker, target, damage, isSkill = false, isCritical = false) {
            return new Promise((resolve) => {
                isAnimating = true;
                
                // è¨­ç½®æ”»æ“Šç‹€æ…‹
                attacker.isAttacking = true;
                target.isBeingAttacked = true;
                
                // æ›´æ–°é¡¯ç¤º
                updateBattleDisplay();
                
                // æ‰¾åˆ°æ”»æ“Šè€…å’Œç›®æ¨™çš„DOMå…ƒç´ 
                const attackerElement = document.querySelector(`[data-card-id="${attacker.originalIndex || attacker.id}"]`);
                const targetElement = document.querySelector(`[data-card-id="${target.originalIndex || target.id}"]`);
                
                // æ”»æ“Šè€…å‹•ç•«
                if (attackerElement) {
                    attackerElement.classList.add(isSkill ? 'skill-attacking' : 'attacking');
                    attackerElement.style.transform = 'scale(1.1)';
                    attackerElement.style.filter = 'brightness(1.3)';
                    
                    setTimeout(() => {
                        attackerElement.style.transform = 'scale(1)';
                        attackerElement.style.filter = 'brightness(1)';
                        attackerElement.classList.remove('attacking', 'skill-attacking');
                    }, isSkill ? 1200 : 800);
                }
                
                // ç›®æ¨™å‹•ç•«
                if (targetElement) {
                    setTimeout(() => {
                        targetElement.style.transform = 'scale(0.9)';
                        targetElement.style.filter = 'brightness(0.7)';
                        
                        // å‰µå»ºå‚·å®³æ•¸å­—
                        const damageText = document.createElement('div');
                        damageText.textContent = `-${damage}`;
                        
                        // åˆ¤æ–·å‚·å®³é¡å‹
                        let damageClass = 'normal';
                        if (isSkill) damageClass = 'skill';
                        if (isCritical) damageClass = 'critical';
                        
                        damageText.className = `damage-number ${damageClass}`;
                        damageText.style.fontSize = isCritical ? '2rem' : '1.5rem';
                        damageText.style.fontWeight = 'bold';
                        
                        // éš¨æ©Ÿä½ç½®åç§»
                        const offsetX = (Math.random() - 0.5) * 30;
                        const offsetY = (Math.random() - 0.5) * 20;
                        damageText.style.left = `calc(50% + ${offsetX}px)`;
                        damageText.style.top = `calc(50% + ${offsetY}px)`;
                        
                        targetElement.appendChild(damageText);
                        
                        setTimeout(() => {
                            targetElement.style.transform = 'scale(1)';
                            targetElement.style.filter = 'brightness(1)';
                            damageText.remove();
                        }, isSkill ? 1200 : 1000);
                    }, isSkill ? 600 : 400);
                }
                
                setTimeout(() => {
                    // æ¸…é™¤æ”»æ“Šç‹€æ…‹
                    attacker.isAttacking = false;
                    target.isBeingAttacked = false;
                    
                    // æ›´æ–°é¡¯ç¤º
                    updateBattleDisplay();
                    
                    isAnimating = false;
                    resolve();
                }, isSkill ? 1200 : 800);
            });
        }

        // æ“Šæ•—å‹•ç•«
        function animateDefeat(card, isPlayer) {
            return new Promise((resolve) => {
                const cardElement = document.querySelector(`[data-card-id="${card.originalIndex || card.id}"]`);
                if (cardElement) {
                    cardElement.classList.add('defeated');
                    
                    // æ“Šæ•—ç‰¹æ•ˆ
                    const defeatEffect = document.createElement('div');
                    defeatEffect.style.cssText = `
                        position: absolute;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        font-size: 2rem;
                        color: #ff4757;
                        text-shadow: 0 0 10px #ff4757;
                        z-index: 1001;
                        animation: damageFloat 1s ease-out forwards;
                    `;
                    defeatEffect.textContent = 'ğŸ’€';
                    cardElement.appendChild(defeatEffect);
                    
                    cardElement.style.transition = 'all 0.5s ease-out';
                    cardElement.style.transform = 'scale(0) rotate(180deg)';
                    cardElement.style.opacity = '0';
                    cardElement.style.filter = 'brightness(0)';
                    
                    setTimeout(() => {
                        defeatEffect.remove();
                        resolve();
                    }, 500);
                } else {
                    resolve();
                }
            });
        }

        // æ ¹æ“šç¨®å­ç”Ÿæˆç¨€æœ‰åº¦
        function getRandomRarity(seed) {
            const raritySeed = seed % 100;
            if (raritySeed < 5) return 'SSR';      // 5% æ©Ÿç‡
            else if (raritySeed < 25) return 'A';  // 20% æ©Ÿç‡
            else return 'R';                        // 75% æ©Ÿç‡
        }

        // ç”Ÿæˆæ•µäººæŠ€èƒ½ï¼ˆé™ä½å¼·åº¦ï¼‰
        function generateEnemySkill(rarity, seed) {
            const skillSeed = seed % 100;
            const skills = [
                { name: 'é˜²ç¦¦å§¿æ…‹', type: 'defense', effect: 'å¢åŠ é˜²ç¦¦åŠ›30%', cooldown: 4 },
                { name: 'é­”æ³•æ”»æ“Š', type: 'magic', effect: 'é€ æˆ1.2å€é­”æ³•å‚·å®³', cooldown: 5 },
                { name: 'æ²»ç™‚è¡“', type: 'heal', effect: 'æ¢å¾©20%è¡€é‡', cooldown: 7 },
                { name: 'åæ“Š', type: 'counter', effect: 'å—åˆ°æ”»æ“Šæ™‚åæ“Š', cooldown: 5 },
                { name: 'ç‹‚æš´', type: 'rage', effect: 'è¡€é‡ä½æ–¼20%æ™‚æ”»æ“ŠåŠ›1.5å€', cooldown: 0 }
            ];
            
            // æ ¹æ“šç¨€æœ‰åº¦é¸æ“‡æŠ€èƒ½
            let selectedSkill;
            switch(rarity) {
                case 'SSR':
                    selectedSkill = skills[skillSeed % 3]; // å‰3å€‹å¼·åŠ›æŠ€èƒ½
                    break;
                case 'A':
                    selectedSkill = skills[Math.floor(skillSeed / 20) + 1]; // ä¸­ç­‰æŠ€èƒ½
                    break;
                case 'R':
                    selectedSkill = skills[Math.floor(skillSeed / 25) + 2]; // åŸºç¤æŠ€èƒ½
                    break;
            }
            
            return {
                ...selectedSkill,
                currentCooldown: 0
            };
        }

        // ç¨€æœ‰åº¦è½‰æ›ï¼ˆä¸­æ–‡â†’è‹±æ–‡æ¨™ç±¤ï¼‰
        function getRarityLabel(rarity) {
            if (rarity === 'è¶…ç¨€æœ‰') return 'SSR';
            if (rarity === 'ç¨€æœ‰') return 'A';
            return 'R';
        }
        function getRarityColor(rarity) {
            if (rarity === 'è¶…ç¨€æœ‰') return '#ffd700';
            if (rarity === 'ç¨€æœ‰') return '#2196f3';
            return '#9c27b0';
        }

        // ç²å–ç¨€æœ‰åº¦èƒŒæ™¯è‰²
        function getRarityBgColor(rarity) {
            switch(rarity) {
                case 'SSR': return 'rgba(255, 215, 0, 0.2)';
                case 'A': return 'rgba(255, 107, 107, 0.2)';
                case 'R': return 'rgba(78, 205, 196, 0.2)';
                default: return 'rgba(78, 205, 196, 0.2)';
            }
        }

        // å‰µå»ºå¡ç‰‡ç¶²æ ¼
        function createCardGrid() {
            console.log('createCardGrid é–‹å§‹åŸ·è¡Œ');
            const cardGrid = document.getElementById('card-grid');
            if (!cardGrid) {
                console.error('æ‰¾ä¸åˆ° card-grid å…ƒç´ ï¼');
                return;
            }
            cardGrid.innerHTML = '';

            if (typeof baseCards === 'undefined') {
                console.log('baseCards æœªå®šç¾©ï¼Œé¡¯ç¤ºè¼‰å…¥ä¸­...');
                cardGrid.innerHTML = '<p>è¼‰å…¥ä¸­...</p>';
                return;
            }

            console.log('é–‹å§‹å‰µå»ºå¡ç‰‡ï¼Œç¸½æ•¸:', baseCards.length);
            baseCards.forEach((card, index) => {
                console.log(`å‰µå»ºå¡ç‰‡ ${index}:`, card.zh || 'ç„¡åç¨±');
                const cardDiv = createCardElement(card, index);
                cardGrid.appendChild(cardDiv);
            });
            console.log('å¡ç‰‡ç¶²æ ¼å‰µå»ºå®Œæˆ');
        }

        // å‰µå»ºå¡ç‰‡å…ƒç´ 
        function createCardElement(card, index) {
            const cardDiv = document.createElement('div');
            cardDiv.className = 'card';
            cardDiv.dataset.cardIndex = index;
            
            // æª¢æŸ¥å¡ç‰Œç­‰ç´š
            const cardLevel = card.level || 1;
            const levelBonus = (cardLevel - 1) * 0.2; // æ¯ç´šå¢åŠ 20%ç´ è³ª
            
            // è¨ˆç®—å‡ç´šå¾Œçš„ç´ è³ª
            const baseAttack = card.attack || 50;
            const baseDefense = card.defense || 30;
            const baseHp = card.hp || 100;
            
            const upgradedAttack = Math.round(baseAttack * (1 + levelBonus));
            const upgradedDefense = Math.round(baseDefense * (1 + levelBonus));
            const upgradedHp = Math.round(baseHp * (1 + levelBonus));
            
            const isSelected = gameState.selectedCards.has(index);
            if (isSelected) {
                cardDiv.classList.add('selected');
            }

            // ç§»é™¤æ‹–æ”¾å±¬æ€§ï¼Œæ”¹ç‚ºé›™æ“Šæ·»åŠ 
            if (!isSelected) {
                cardDiv.setAttribute('draggable', 'false');
            }

            const imageSrc = card.image || 'img/card_back.jpeg';
            let mediaContent = '';
            
            if (card.image && card.image.endsWith('.mp4')) {
                mediaContent = `<video class="card-media" is-video src="${card.image}" muted preload="metadata" playsinline loop></video>`;
            } else {
                mediaContent = `<img class="card-media" src="${imageSrc}" alt="${card.zh}" onerror="this.src='img/card_back.jpeg'">`;
            }

            // ç¨€æœ‰åº¦æ¨™ç±¤
            const rarityLabel = getRarityLabel(card.rarity);
            const rarityColor = getRarityColor(card.rarity);
            const rarityTag = `<div style="position:absolute;top:3px;right:3px;background:${rarityColor};color:#fff;font-size:0.7rem;font-weight:bold;padding:2px 7px;border-radius:6px;box-shadow:0 0 6px ${rarityColor}99;z-index:2;">${rarityLabel}</div>`;

                                // ç­‰ç´šæ¨™ç±¤
                    const levelTag = cardLevel > 1 ? `<div style="position:absolute;left:3px;top:3px;background:rgba(255,215,0,0.8);color:#000;font-size:0.6rem;font-weight:bold;padding:1px 4px;border-radius:4px;z-index:3;">Lv.${cardLevel}</div>` : '';
                    
                    // ç¶“é©—å€¼é€²åº¦æ¢
                    const currentExp = card.exp || 0;
                    const requiredExp = getExpForNextLevel(cardLevel);
                    const expProgress = Math.min(100, Math.round((currentExp / requiredExp) * 100));
                    const remainingExp = requiredExp - currentExp;
                    const expBar = `<div style="width: 100%; height: 4px; background: #333; border-radius: 2px; margin-top: 2px; position: relative;">
                        <div style="width: ${expProgress}%; height: 100%; background: linear-gradient(90deg, #4ecdc4, #45b7d1); border-radius: 2px; box-shadow: 0 0 4px rgba(78, 205, 196, 0.6);"></div>
                    </div>
                    <div style="font-size: 0.4rem; color: #ffd700; margin-top: 1px; text-align: center;">
                        ${currentExp}/${requiredExp} (é‚„å·®${remainingExp})
                    </div>`;
                    

                    
                    cardDiv.innerHTML = `
                        ${rarityTag}
                        ${levelTag}
                        ${mediaContent}
                        <div style="position: absolute; bottom: 0; left: 0; right: 0; background: rgba(0,0,0,0.8); padding: 3px; font-size: 0.65rem; text-align: center;">
                            <div style="font-weight: bold; margin-bottom: 2px;">${card.zh}</div>
                            <div style="display: flex; justify-content: space-between; font-size: 0.5rem; opacity: 0.9;">
                                <span style="color: #ff6b6b;">æ”»:${upgradedAttack}</span>
                                <span style="color: #4ecdc4;">é˜²:${upgradedDefense}</span>
                                <span style="color: #45b7d1;">è¡€:${upgradedHp}</span>
                            </div>
                            <div style="font-size: 0.45rem; color: #ffd700; margin-top: 2px;">${card.skill ? card.skill.name : 'ç„¡æŠ€èƒ½'}</div>
                            ${expBar}
                        </div>
                    `;

            // è™•ç†å½±ç‰‡æ’­æ”¾
            const video = cardDiv.querySelector('video');
            if (video) {
                cardDiv.addEventListener('mouseenter', () => {
                    if (!isSelected) video.play();
                });
                cardDiv.addEventListener('mouseleave', () => {
                    video.pause();
                    video.currentTime = 0;
                });
                video.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (!isSelected) {
                        if (video.paused) video.play();
                        else video.pause();
                    }
                });
            }

            // å–®æ“Šé¡¯ç¤ºå¡ç‰‡è©³æƒ…ï¼Œé›™æ“Šæ·»åŠ åˆ°éšŠä¼
            let clickTimer = null;
            cardDiv.addEventListener('click', (e) => {
                if (clickTimer) {
                    clearTimeout(clickTimer);
                    clickTimer = null;
                    // é›™æ“Šæ·»åŠ åˆ°éšŠä¼
                    if (!isSelected) {
                        // æª¢æŸ¥éšŠä¼æ˜¯å¦å·²æ»¿
                        if (gameState.playerTeam.length >= 4) {
                            addLogEntry('ç³»çµ±', 'éšŠä¼å·²æ»¿ï¼Œç„¡æ³•æ·»åŠ æ›´å¤šå¡ç‰‡ï¼');
                            return;
                        }
                        
                        // æ·»åŠ åˆ°éšŠä¼
                        const card = baseCards[index];
                        const slotIndex = gameState.playerTeam.length;
                        
                        gameState.playerTeam.push({
                            ...card,
                            originalIndex: index
                        });

                        // æ¨™è¨˜ç‚ºå·²é¸å…¥éšŠä¼ï¼ˆä½†æœªä½¿ç”¨ï¼‰
                        gameState.selectedCards.add(index);

                        // æ›´æ–°UI
                        updateTeamDisplay();
                        updateCardGrid();
                        updateTeamStats();
                        
                        addLogEntry('ç³»çµ±', `é›™æ“Šæ·»åŠ å¡ç‰‡åˆ°éšŠä¼ï¼š${card.zh}`);
                    }
                } else {
                    clickTimer = setTimeout(() => {
                        // å–®æ“Šé¡¯ç¤ºå¡ç‰‡è©³æƒ…
                        showCardDetailModal(card);
                        clickTimer = null;
                    }, 250);
                }
            });

            return cardDiv;
        }

        // é¸æ“‡å¡ç‰‡
        function selectCard(cardIndex) {
            if (gameState.playerTeam.length >= 4) {
                addLogEntry('ç³»çµ±', 'éšŠä¼å·²æ»¿ï¼Œç„¡æ³•æ·»åŠ æ›´å¤šå¡ç‰‡ï¼');
                return;
            }

            const card = baseCards[cardIndex];
            const slotIndex = gameState.playerTeam.length;
            
            // æ·»åŠ åˆ°éšŠä¼
            gameState.playerTeam.push({
                ...card,
                originalIndex: cardIndex
            });

            // æ¨™è¨˜ç‚ºå·²é¸å…¥éšŠä¼ï¼ˆä½†æœªä½¿ç”¨ï¼‰
            gameState.selectedCards.add(cardIndex);

            // æ›´æ–°UI
            updateTeamDisplay();
            updateCardGrid();
            updateTeamStats();
            
            addLogEntry('ç³»çµ±', `å·²é¸æ“‡å¡ç‰‡ï¼š${card.zh}`);
        }

        // æ›´æ–°éšŠä¼é¡¯ç¤º
        function updateTeamDisplay() {
            const teamSlots = document.querySelectorAll('.team-slot');
            
            teamSlots.forEach((slot, index) => {
                slot.innerHTML = '';
                slot.setAttribute('data-slot', index);
                slot.classList.remove('drag-over');
                
                if (index < gameState.playerTeam.length) {
                    const card = gameState.playerTeam[index];
                    const imageSrc = card.image || 'img/card_back.jpeg';
                    
                    let mediaContent = '';
                    if (card.image && card.image.endsWith('.mp4')) {
                        mediaContent = `<video class="card-media" is-video src="${card.image}" muted preload="metadata" playsinline loop></video>`;
                    } else {
                        mediaContent = `<img class="card-media" src="${imageSrc}" alt="${card.zh}" onerror="this.src='img/card_back.jpeg'">`;
                    }
                    // ç¨€æœ‰åº¦æ¨™ç±¤
                    const rarityLabel = getRarityLabel(card.rarity);
                    const rarityColor = getRarityColor(card.rarity);
                    const rarityTag = `<div style="position:absolute;top:3px;right:3px;background:${rarityColor};color:#fff;font-size:0.7rem;font-weight:bold;padding:2px 7px;border-radius:6px;box-shadow:0 0 6px ${rarityColor}99;z-index:2;">${rarityLabel}</div>`;
                    
                    // åˆ¤æ–·æ˜¯å¦é–å®šï¼ˆè¢«æ‰“æ•—ï¼‰
                    const isLocked = false;
                    let lockTag = '';
                    if (isLocked) {
                        lockTag = `<div style="position:absolute;left:3px;top:3px;background:rgba(0,0,0,0.7);color:#ffd700;font-size:0.8rem;font-weight:bold;padding:2px 6px;border-radius:6px;z-index:3;display:flex;align-items:center;"><span style='font-size:1.1em;margin-right:2px;'>ğŸ”’</span>é–å®š</div>`;
                    }
                    // æª¢æŸ¥ç³»åˆ—æ•ˆæœ
                    const seriesEffects = gameState.seriesEffects || {};
                    const cardSeries = card.series || 'ç„¡ç³»åˆ—';
                    const hasSeriesBonus = seriesEffects[cardSeries];
                    const seriesTag = hasSeriesBonus ? `<div style="position:absolute;left:3px;top:3px;background:rgba(255,215,0,0.8);color:#000;font-size:0.6rem;font-weight:bold;padding:1px 4px;border-radius:4px;z-index:3;">ç³»åˆ—</div>` : '';
                    
                    // æª¢æŸ¥å¡ç‰Œç­‰ç´š
                    const cardLevel = card.level || 1;
                    const levelBonus = (cardLevel - 1) * 0.2;
                    const baseAttack = card.attack || 50;
                    const baseDefense = card.defense || 30;
                    const baseHp = card.hp || 100;
                    const upgradedAttack = Math.round(baseAttack * (1 + levelBonus));
                    const upgradedDefense = Math.round(baseDefense * (1 + levelBonus));
                    const upgradedHp = Math.round(baseHp * (1 + levelBonus));
                    
                    // ç­‰ç´šæ¨™ç±¤
                    const levelTag = cardLevel > 1 ? `<div style="position:absolute;left:3px;top:3px;background:rgba(255,215,0,0.8);color:#000;font-size:0.6rem;font-weight:bold;padding:1px 4px;border-radius:4px;z-index:3;">Lv.${cardLevel}</div>` : '';
                    
                    // ç¶“é©—å€¼é€²åº¦æ¢
                    const currentExp = card.exp || 0;
                    const requiredExp = getExpForNextLevel(cardLevel);
                    const expProgress = Math.min(100, Math.round((currentExp / requiredExp) * 100));
                    const remainingExp = requiredExp - currentExp;
                    const expBar = `<div style="width: 100%; height: 4px; background: #333; border-radius: 2px; margin-top: 2px; position: relative;">
                        <div style="width: ${expProgress}%; height: 100%; background: linear-gradient(90deg, #4ecdc4, #45b7d1); border-radius: 2px; box-shadow: 0 0 4px rgba(78, 205, 196, 0.6);"></div>
                    </div>
                    <div style="font-size: 0.4rem; color: #ffd700; margin-top: 1px; text-align: center;">
                        ${currentExp}/${requiredExp} (é‚„å·®${remainingExp})
                    </div>`;
                    
                    slot.innerHTML = `
                        ${rarityTag}
                        ${lockTag}
                        ${seriesTag}
                        ${levelTag}
                        ${mediaContent}
                        <div style="position: absolute; bottom: 0; left: 0; right: 0; background: rgba(0,0,0,0.8); padding: 3px; font-size: 0.65rem; text-align: center;">
                            <div style="font-weight: bold; margin-bottom: 2px;">${card.zh}</div>
                            <div style="display: flex; justify-content: space-between; font-size: 0.5rem; opacity: 0.9;">
                                <span style="color: #ff6b6b;">æ”»:${upgradedAttack}</span>
                                <span style="color: #4ecdc4;">é˜²:${upgradedDefense}</span>
                                <span style="color: #45b7d1;">è¡€:${upgradedHp}</span>
                            </div>
                            <div style="font-size: 0.45rem; color: #ffd700; margin-top: 2px;">${card.skill ? card.skill.name : 'ç„¡æŠ€èƒ½'}</div>
                            ${expBar}
                        </div>
                    `;
                    slot.classList.add('filled');
                    if (isLocked) {
                        slot.style.opacity = '0.5';
                        slot.style.pointerEvents = 'none';
                        slot.style.filter = 'grayscale(0.7) blur(1px)';
                    } else {
                        slot.style.opacity = '1';
                        slot.style.pointerEvents = '';
                        slot.style.filter = '';
                        // æ·»åŠ é›™æ“Šç§»é™¤å¡ç‰‡åŠŸèƒ½
                        let slotClickTimer = null;
                        slot.addEventListener('click', () => {
                            if (slotClickTimer) {
                                clearTimeout(slotClickTimer);
                                slotClickTimer = null;
                                // é›™æ“Šç§»é™¤å¡ç‰‡
                                removeCardFromSlot(index);
                            } else {
                                slotClickTimer = setTimeout(() => {
                                    // å–®æ“Šä¸åšä»»ä½•æ“ä½œ
                                    slotClickTimer = null;
                                }, 250);
                            }
                        });
                    }
                    // è™•ç†å½±ç‰‡æ’­æ”¾
                    const video = slot.querySelector('video');
                    if (video) {
                        slot.addEventListener('mouseenter', () => video.play());
                        slot.addEventListener('mouseleave', () => {
                            video.pause();
                            video.currentTime = 0;
                        });
                    }
                } else {
                    slot.innerHTML = '<span>æ‹–æ”¾å¡ç‰Œ</span>';
                    slot.classList.remove('filled');
                }
            });
        }

        // æ‹–æ”¾åˆ°éšŠä¼æ¬„ä½çš„é‚è¼¯
        function dropCardToSlot(cardIndex, slotIndex) {
            // å…ˆæª¢æŸ¥è©²å¡ç‰‡æ˜¯å¦å·²ç¶“åœ¨éšŠä¼ä¸­
            const alreadyInTeam = gameState.playerTeam.some(c => c.originalIndex === cardIndex);
            if (alreadyInTeam) return;
            // æª¢æŸ¥è©²å¡ç‰‡æ˜¯å¦å·²ç¶“è¢«ä½¿ç”¨ï¼ˆæˆ°é¬¥å¾Œï¼‰

            
            // å–å¾—å¡ç‰‡è³‡æ–™
            const card = baseCards[cardIndex];
            const cardData = {
                ...card,
                hp: card.hp || 100,
                attack: card.attack || 0,
                defense: card.defense || 0,
                originalIndex: cardIndex
            };
            // å¦‚æœè©²æ¬„ä½å·²ç¶“æœ‰å¡ç‰‡ï¼Œè¦†è“‹
            if (slotIndex < gameState.playerTeam.length) {
                gameState.playerTeam[slotIndex] = cardData;
            } else {
                // å¦‚æœè©²æ¬„ä½æ˜¯ç©ºçš„ï¼Œç›´æ¥æ”¾é€²å»
                gameState.playerTeam.push(cardData);
            }
            // æ¨™è¨˜ç‚ºå·²é¸å…¥éšŠä¼ï¼ˆä½†æœªä½¿ç”¨ï¼‰
            gameState.selectedCards.add(cardIndex);
            updateTeamDisplay();
            updateCardGrid();
            updateTeamStats();
            addLogEntry('ç³»çµ±', `æ‹–æ”¾å¡ç‰‡ï¼š${card.zh}`);
        }

        // ç§»é™¤å¡ç‰‡å¾éšŠä¼æ¬„ä½
        function removeCardFromSlot(slotIndex) {
            if (slotIndex >= gameState.playerTeam.length) return;

            const removedCard = gameState.playerTeam.splice(slotIndex, 1)[0];
            gameState.selectedCards.delete(removedCard.originalIndex);
            updateTeamDisplay();
            updateCardGrid();
            updateTeamStats();
            addLogEntry('ç³»çµ±', `ç§»é™¤å¡ç‰‡ï¼š${removedCard.zh}`);
        }

        // æ›´æ–°å¡ç‰‡ç¶²æ ¼
        function updateCardGrid() {
            const cards = document.querySelectorAll('.card');
            cards.forEach((cardDiv, index) => {
                const isSelected = gameState.selectedCards.has(index);
                const isUsed = false;
                cardDiv.classList.remove('used', 'selected', 'ssr', 'a', 'r');
                if (isUsed) {
                    cardDiv.classList.add('used');
                } else if (isSelected) {
                    cardDiv.classList.add('selected');
                }
                // æ ¹æ“šç¨€æœ‰åº¦è¨­å®šèƒŒæ™¯å’Œé‚Šæ¡†é¡è‰²
                if (baseCards[index] && baseCards[index].rarity) {
                    cardDiv.classList.add(baseCards[index].rarity.toLowerCase());
                }
            });
        }

        // æª¢æŸ¥åŒä¸€ç³»åˆ—å¡ç‰Œæ•ˆæœ
        function checkSeriesBonus() {
            const seriesCount = {};
            const seriesEffects = {};
            
            // çµ±è¨ˆæ¯å€‹ç³»åˆ—çš„å¡ç‰Œæ•¸é‡
            gameState.playerTeam.forEach(card => {
                const series = card.series || 'ç„¡ç³»åˆ—';
                seriesCount[series] = (seriesCount[series] || 0) + 1;
            });
            
            // è¨ˆç®—ç³»åˆ—æ•ˆæœ
            Object.keys(seriesCount).forEach(series => {
                const count = seriesCount[series];
                if (count >= 2) {
                    // 2å¼µåŒç³»åˆ—ï¼š20%æš´æ“Šç‡
                    if (count === 2) {
                        seriesEffects[series] = { type: 'critical', bonus: 0.2, description: '20%æš´æ“Šç‡' };
                    }
                    // 3å¼µåŒç³»åˆ—ï¼š30%æš´æ“Šç‡ + 10%å‚·å®³åŠ æˆ
                    else if (count === 3) {
                        seriesEffects[series] = { type: 'critical_damage', bonus: 0.3, damageBonus: 0.1, description: '30%æš´æ“Šç‡ + 10%å‚·å®³åŠ æˆ' };
                    }
                    // 4å¼µåŒç³»åˆ—ï¼š50%æš´æ“Šç‡ + 20%å‚·å®³åŠ æˆ + 15%é˜²ç¦¦åŠ æˆ
                    else if (count >= 4) {
                        seriesEffects[series] = { type: 'full_bonus', bonus: 0.5, damageBonus: 0.2, defenseBonus: 0.15, description: '50%æš´æ“Šç‡ + 20%å‚·å®³åŠ æˆ + 15%é˜²ç¦¦åŠ æˆ' };
                    }
                }
            });
            
            return seriesEffects;
        }

        // æ›´æ–°éšŠä¼çµ±è¨ˆï¼ˆåŒ…å«ç³»åˆ—æ•ˆæœå’Œç­‰ç´šåŠ æˆï¼‰
        function updateTeamStats() {
            let totalAttack = 0;
            let totalDefense = 0;
            let totalHp = 0;
            
            gameState.playerTeam.forEach(card => {
                // è¨ˆç®—å‡ç´šå¾Œçš„ç´ è³ª
                const cardLevel = card.level || 1;
                const levelBonus = (cardLevel - 1) * 0.2;
                const baseAttack = card.attack || 50;
                const baseDefense = card.defense || 30;
                const baseHp = card.hp || 100;
                
                const upgradedAttack = Math.round(baseAttack * (1 + levelBonus));
                const upgradedDefense = Math.round(baseDefense * (1 + levelBonus));
                const upgradedHp = Math.round(baseHp * (1 + levelBonus));
                
                totalAttack += upgradedAttack;
                totalDefense += upgradedDefense;
                totalHp += upgradedHp;
            });

            // æª¢æŸ¥ç³»åˆ—æ•ˆæœ
            const seriesEffects = checkSeriesBonus();
            let seriesDescription = 'ç„¡';
            
            if (Object.keys(seriesEffects).length > 0) {
                const effects = Object.values(seriesEffects).map(effect => effect.description);
                seriesDescription = effects.join('ã€');
            }

            document.getElementById('current-stage').textContent = `ç¬¬${currentStage}é—œ`;
            document.getElementById('total-attack').textContent = totalAttack;
            document.getElementById('total-defense').textContent = totalDefense;
            document.getElementById('total-hp').textContent = totalHp;
            document.getElementById('team-skill').textContent = seriesDescription;
            
            // å„²å­˜ç³»åˆ—æ•ˆæœä¾›æˆ°é¬¥ä½¿ç”¨
            gameState.seriesEffects = seriesEffects;
        }

        // é—œå¡é€²åº¦è¿½è¹¤
        let currentStage = parseInt(localStorage.getItem('battleStage') || '1');
        let stageMultiplier = 1 + (currentStage - 1) * 0.15; // æ¯é—œå¢åŠ 15%å¼·åº¦ï¼ˆé™ä½é›£åº¦ï¼‰

        // ç”Ÿæˆæ•µäººéšŠä¼ï¼ˆè§£é—œå¡æ„Ÿè¦º + è¶Šæ‰“è¶Šå¼·ï¼‰
        function generateEnemyTeam() {
            const enemyCount = Math.min(4, gameState.playerTeam.length); // æ•µäººæ•¸é‡èˆ‡ç©å®¶éšŠä¼ç›¸åŒ
            gameState.enemyTeam = [];
            
            // è¨ˆç®—ç©å®¶éšŠä¼ç¸½æˆ°åŠ›
            const playerTotalAttack = gameState.playerTeam.reduce((sum, card) => sum + (card.attack || 0), 0);
            const playerTotalDefense = gameState.playerTeam.reduce((sum, card) => sum + (card.defense || 0), 0);
            const playerTotalHp = gameState.playerTeam.reduce((sum, card) => sum + (card.hp || 0), 0);
            const playerAvgLevel = (playerTotalAttack + playerTotalDefense + playerTotalHp) / (gameState.playerTeam.length * 3);
            
            // å¾baseCardsä¸­é¸æ“‡æ•µäººå¡ç‰Œ
            const availableCards = baseCards.filter(card => card.zh && card.zh.trim() !== '');
            
            for (let i = 0; i < enemyCount; i++) {
                const seed = Date.now() + i * 1000;
                const rarity = getRandomRarity(seed);
                
                // éš¨æ©Ÿé¸æ“‡ä¸€å¼µå¡ç‰Œä½œç‚ºæ•µäººåŸºç¤
                const randomCard = availableCards[Math.floor(Math.random() * availableCards.length)];
                
                // æ ¹æ“šç¨€æœ‰åº¦èª¿æ•´æ•µäººå¼·åº¦ï¼ˆé™ä½ç¨€æœ‰åº¦å½±éŸ¿ï¼‰
                let rarityMultiplier = 1;
                switch(rarity) {
                    case 'SSR': rarityMultiplier = 1.2; break; // é™ä½SSRå¼·åº¦
                    case 'A': rarityMultiplier = 1.1; break;   // é™ä½Aç´šå¼·åº¦
                    case 'R': rarityMultiplier = 1.0; break;   // ä¿æŒRç´šä¸è®Š
                }
                
                // ç”Ÿæˆå¹³è¡¡çš„æ•µäººï¼ˆé™ä½å¼·åº¦ï¼‰
                const enemy = {
                    zh: `${randomCard.zh}`, // ä½¿ç”¨å¡ç‰Œåå­—
                    attack: Math.round(playerAvgLevel * 1.8 * rarityMultiplier * stageMultiplier * (0.9 + Math.random() * 0.2)),
                    defense: Math.round(playerAvgLevel * 1.8 * rarityMultiplier * stageMultiplier * (0.9 + Math.random() * 0.2)),
                    hp: Math.round(playerAvgLevel * 2.2 * rarityMultiplier * stageMultiplier * (0.9 + Math.random() * 0.2)),
                    maxHp: Math.round(playerAvgLevel * 2.2 * rarityMultiplier * stageMultiplier * (0.9 + Math.random() * 0.2)),
                    rarity: rarity,
                    skill: generateEnemySkill(rarity, seed),
                    level: i + 1, // é—œå¡ç­‰ç´š
                    stage: currentStage, // ç•¶å‰é—œå¡
                    image: randomCard.image, // ä½¿ç”¨å¡ç‰Œåœ–ç‰‡
                    series: randomCard.series // ä½¿ç”¨å¡ç‰Œç³»åˆ—
                };
                
                gameState.enemyTeam.push(enemy);
            }
            
            console.log(`ç”Ÿæˆç¬¬${currentStage}é—œæ•µäººéšŠä¼ï¼š`, gameState.enemyTeam.length, 'å€‹æ•µäººï¼Œå¹³å‡ç­‰ç´šï¼š', playerAvgLevel, 'é—œå¡å€ç‡ï¼š', stageMultiplier);
        }

        // æ›´æ–°æˆ°é¬¥é¡¯ç¤º
        function updateBattleDisplay() {
            const enemyArea = document.getElementById('enemy-area');
            const playerArea = document.getElementById('player-area');
            
            if (!enemyArea || !playerArea) return;
            
            // æ¸…ç©ºå€åŸŸ
            enemyArea.innerHTML = '';
            playerArea.innerHTML = '';
            
            // é¡¯ç¤ºæ•µäººå¡ç‰Œ
            gameState.enemyTeam.forEach((enemy, index) => {
                const enemyCard = createBattleCardElement(enemy, 'enemy', index);
                enemyArea.appendChild(enemyCard);
            });
            
            // é¡¯ç¤ºç©å®¶å¡ç‰Œ
            gameState.playerTeam.forEach((card, index) => {
                const playerCard = createBattleCardElement(card, 'player', index);
                playerArea.appendChild(playerCard);
            });
            
            console.log('æ›´æ–°æˆ°é¬¥é¡¯ç¤ºï¼š', gameState.enemyTeam.length, 'å€‹æ•µäººï¼Œ', gameState.playerTeam.length, 'å€‹ç©å®¶');
        }

        // å‰µå»ºæˆ°é¬¥å¡ç‰‡å…ƒç´ 
        function createBattleCardElement(card, type, index) {
            const cardDiv = document.createElement('div');
            cardDiv.className = type === 'enemy' ? 'enemy-card' : 'player-card';
            cardDiv.dataset.index = index;
            cardDiv.dataset.cardId = card.originalIndex || card.id || `battle-${type}-${index}`;
            // æ–°å¢ç¨€æœ‰åº¦ class
            if (card.rarity) {
                cardDiv.classList.add(card.rarity.toLowerCase());
            }
            
            // æª¢æŸ¥æ”»æ“Šç‹€æ…‹
            const isAttacking = card.isAttacking || false;
            const isBeingAttacked = card.isBeingAttacked || false;
            
            // æ ¹æ“šæ”»æ“Šç‹€æ…‹æ·»åŠ CSSé¡
            if (isAttacking) {
                cardDiv.classList.add('attacking');
            }
            if (isBeingAttacked) {
                cardDiv.classList.add('being-attacked');
            }
            
            const imageSrc = card.image || 'img/card_back.jpeg';
            let mediaContent = '';
            
            if (card.image && card.image.endsWith('.mp4')) {
                mediaContent = `<video class="card-media" is-video src="${card.image}" muted preload="metadata" playsinline loop></video>`;
            } else {
                mediaContent = `<img class="card-media" src="${imageSrc}" alt="${card.zh}" onerror="this.src='img/card_back.jpeg'">`;
            }
            // ç¨€æœ‰åº¦æ¨™ç±¤
            const rarityLabel = getRarityLabel(card.rarity);
            const rarityColor = getRarityColor(card.rarity);
            const rarityTag = `<div style="position:absolute;top:3px;right:3px;background:${rarityColor};color:#fff;font-size:0.7rem;font-weight:bold;padding:2px 7px;border-radius:6px;box-shadow:0 0 6px ${rarityColor}99;z-index:2;">${rarityLabel}</div>`;

            // è¨ˆç®—å‡ç´šå¾Œçš„ç´ è³ª
            const cardLevel = card.level || 1;
            const levelBonus = (cardLevel - 1) * 0.2;
            const baseAttack = card.attack || 50;
            const baseDefense = card.defense || 30;
            const baseHp = card.hp || 100;
            
            const upgradedAttack = Math.round(baseAttack * (1 + levelBonus));
            const upgradedDefense = Math.round(baseDefense * (1 + levelBonus));
            const upgradedHp = Math.round(baseHp * (1 + levelBonus));
            
            // è¡€æ¢ï¼ˆä½¿ç”¨å‡ç´šå¾Œçš„ç´ è³ªï¼‰
            const hp = Math.round(card.hp || upgradedHp);
            const maxHp = Math.round(card.maxHp || upgradedHp);
            const hpPercent = Math.max(0, Math.min(100, Math.round((hp / maxHp) * 100)));
            const hpBar = `<div style="width: 90%; height: 10px; background: #222; border-radius: 5px; margin: 2px auto 0 auto; position: relative;">
                <div style="width: ${hpPercent}%; height: 100%; background: linear-gradient(90deg, #ff6b6b, #ffe066); border-radius: 5px;"></div>
                <span style="position: absolute; left: 50%; top: 50%; transform: translate(-50%,-50%); font-size: 0.65em; color: #fff; text-shadow: 0 0 2px #000;">${hp}/${maxHp}</span>
            </div>`;

            // ç­‰ç´šæ¨™ç±¤
            const levelTag = cardLevel > 1 ? `<div style="position:absolute;left:3px;top:3px;background:rgba(255,215,0,0.8);color:#000;font-size:0.6rem;font-weight:bold;padding:1px 4px;border-radius:4px;z-index:3;">Lv.${cardLevel}</div>` : '';
            
            // æª¢æŸ¥æ˜¯å¦è™•æ–¼é˜²ç¦¦ç‹€æ…‹
            const isDefending = card.isDefending || false;
            const defendStatus = isDefending ? '<div style="position:absolute;left:3px;top:3px;background:rgba(255,215,0,0.8);color:#000;font-size:0.7rem;font-weight:bold;padding:2px 6px;border-radius:6px;z-index:3;">ğŸ›¡ï¸é˜²ç¦¦</div>' : '';
            
            // æ”»æ“Šç‹€æ…‹æ¨™ç±¤
            const attackStatus = isAttacking ? '<div style="position:absolute;left:3px;top:3px;background:rgba(255,107,107,0.9);color:#fff;font-size:0.7rem;font-weight:bold;padding:2px 6px;border-radius:6px;z-index:3;animation:pulse 0.5s infinite;">âš”ï¸æ”»æ“Š</div>' : '';
            const beingAttackedStatus = isBeingAttacked ? '<div style="position:absolute;left:3px;top:3px;background:rgba(255,0,0,0.9);color:#fff;font-size:0.7rem;font-weight:bold;padding:2px 6px;border-radius:6px;z-index:3;animation:shake 0.3s infinite;">ğŸ’¥å—æ“Š</div>' : '';
            
            // ç´ è³ªé¡¯ç¤ºï¼ˆæ”»æ“ŠåŠ›ã€é˜²ç¦¦åŠ›ï¼‰
            const attackDisplay = `<div style="font-size: 0.55rem; color: #ff6b6b; margin-top: 1px;">âš”ï¸${upgradedAttack}</div>`;
            const defenseDisplay = `<div style="font-size: 0.55rem; color: #4ecdc4; margin-top: 1px;">ğŸ›¡ï¸${upgradedDefense}</div>`;
            
            cardDiv.innerHTML = `
                ${rarityTag}
                ${levelTag}
                ${defendStatus}
                ${attackStatus}
                ${beingAttackedStatus}
                ${mediaContent}
                <div style="position: absolute; bottom: 0; left: 0; right: 0; background: rgba(0,0,0,0.8); padding: 3px; font-size: 0.8rem; text-align: center;">
                    <div>${card.zh}</div>
                    ${hpBar}
                    ${attackDisplay}
                    ${defenseDisplay}
                    <div style="font-size: 0.55rem; color: #ffd700; margin-top: 1px;">${card.skill ? card.skill.name : 'ç„¡æŠ€èƒ½'}</div>
                </div>
            `;

            // è™•ç†å½±ç‰‡æ’­æ”¾
            const video = cardDiv.querySelector('video');
            if (video) {
                cardDiv.addEventListener('mouseenter', () => video.play());
                cardDiv.addEventListener('mouseleave', () => {
                    video.pause();
                    video.currentTime = 0;
                });
                video.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (video.paused) video.play();
                    else video.pause();
                });
            }

            // ç‚ºæ•µäººå¡ç‰‡æ·»åŠ é»æ“Šæ”»æ“ŠåŠŸèƒ½
            if (type === 'enemy') {
                cardDiv.style.cursor = 'pointer';
                cardDiv.addEventListener('click', () => {
                    if (currentAttacker === 0 && !isAnimating) { // ç©å®¶å›åˆä¸”ä¸åœ¨å‹•ç•«ä¸­
                        attackEnemy(index);
                    }
                });
            }

            return cardDiv;
        }

        // é–‹å§‹æˆ°é¬¥
        async function startBattle() {
            if (gameState.playerTeam.length === 0) {
                addLogEntry('ç³»çµ±', 'è«‹å…ˆé¸æ“‡å¡ç‰‡çµ„æˆéšŠä¼ï¼');
                return;
            }

            if (gameState.isBattleActive) {
                addLogEntry('ç³»çµ±', 'æˆ°é¬¥æ­£åœ¨é€²è¡Œä¸­ï¼');
                return;
            }

            // æª¢æŸ¥æ˜Ÿæ˜Ÿæ•¸é‡
            const currentStars = getCurrentStars();
            console.log('ç•¶å‰æ˜Ÿæ˜Ÿæ•¸é‡:', currentStars);
            if (currentStars < 10) {
                addLogEntry('ç³»çµ±', 'æ˜Ÿæ˜Ÿä¸è¶³ï¼éœ€è¦10é¡†æ˜Ÿæ˜Ÿæ‰èƒ½é–‹å§‹æˆ°é¬¥ã€‚');
                return;
            }
            // æ‰£é™¤10é¡†æ˜Ÿæ˜Ÿ
            addStarsToBattle(-10);
            console.log('å·²æ‰£é™¤10é¡†æ˜Ÿæ˜Ÿï¼Œç•¶å‰æ˜Ÿæ˜Ÿ:', getCurrentStars());
            addLogEntry('ç³»çµ±', 'ğŸ’ æ¶ˆè€—10é¡†æ˜Ÿæ˜Ÿé–‹å§‹æˆ°é¬¥ï¼');
            await new Promise(resolve => setTimeout(resolve, 500));
            addLogEntry('ç³»çµ±', 'âš”ï¸ æˆ°é¬¥å³å°‡é–‹å§‹...');
            await new Promise(resolve => setTimeout(resolve, 600));
            addLogEntry('ç³»çµ±', 'ğŸ”¥ æ•µäººæ­£åœ¨é€¼è¿‘ï¼');
            await new Promise(resolve => setTimeout(resolve, 500));

            // æˆ°é¬¥é–‹å§‹æ™‚ï¼Œä¸æ¨™è¨˜å¡ç‰‡ç‚ºå·²ä½¿ç”¨ï¼Œåªç§»é™¤ selected æ¨™è¨˜
            gameState.playerTeam.forEach(card => {
                if (card.originalIndex !== undefined) {
                    gameState.selectedCards.delete(card.originalIndex);
                }
            });
            
            // ä¿å­˜åŸå§‹éšŠä¼çš„å‰¯æœ¬ï¼Œç”¨æ–¼ç¶“é©—å€¼çµç®—
            gameState.originalTeam = [...gameState.playerTeam];
            
            // è¨ˆç®—å‡ç´šå¾Œçš„ç´ è³ªä¸¦æ‡‰ç”¨åˆ°æˆ°é¬¥éšŠä¼
            gameState.playerTeam = gameState.playerTeam.map(card => {
                const cardLevel = card.level || 1;
                const levelBonus = (cardLevel - 1) * 0.2;
                const baseAttack = card.attack || 50;
                const baseDefense = card.defense || 30;
                const baseHp = card.hp || 100;
                
                const upgradedAttack = Math.round(baseAttack * (1 + levelBonus));
                const upgradedDefense = Math.round(baseDefense * (1 + levelBonus));
                const upgradedHp = Math.round(baseHp * (1 + levelBonus));
                
                return {
                    ...card,
                    attack: upgradedAttack,
                    defense: upgradedDefense,
                    hp: upgradedHp,
                    maxHp: upgradedHp
                };
            });
            
            updateCardGrid();

            gameState.isBattleActive = true;
            gameState.currentTurn = 0;
            gameState.hasAttacked = false; // åˆå§‹åŒ–æ”»æ“Šæ¨™è¨˜
            gameState.starsAdded = false; // é‡ç½®æ˜Ÿæ˜Ÿçå‹µæ¨™è¨˜
            
            generateEnemyTeam();
            updateBattleDisplay();
            
            // é¡¯ç¤ºé—œå¡ä¿¡æ¯
            addLogEntry('ç³»çµ±', `âš”ï¸ ç¬¬${currentStage}é—œæˆ°é¬¥é–‹å§‹ï¼`);
            await new Promise(resolve => setTimeout(resolve, 400));
            addLogEntry('ç³»çµ±', `ğŸ¯ æ•µäººå¼·åº¦å€ç‡ï¼š${stageMultiplier.toFixed(1)}xï¼ˆå·²å¹³è¡¡ï¼‰`);
            await new Promise(resolve => setTimeout(resolve, 400));
            addLogEntry('ç³»çµ±', `ğŸ‘¹ æ•µäººæ•¸é‡ï¼š${gameState.enemyTeam.length}ï¼Œç©å®¶éšŠä¼ï¼š${gameState.playerTeam.length}äºº`);
            await new Promise(resolve => setTimeout(resolve, 400));
            
            // é¡¯ç¤ºæ•µäººå¡ç‰Œåå­—
            const enemyNames = gameState.enemyTeam.map(enemy => enemy.zh).join('ã€');
            addLogEntry('ç³»çµ±', `ğŸ¯ æ•µäººå¡ç‰Œï¼š${enemyNames}`);
            await new Promise(resolve => setTimeout(resolve, 400));
            
            // æª¢æŸ¥ç³»åˆ—æ•ˆæœ
            const seriesEffects = checkSeriesBonus();
            if (Object.keys(seriesEffects).length > 0) {
                addLogEntry('ç³»çµ±', 'ğŸŒŸ æª¢æ¸¬åˆ°åŒç³»åˆ—å¡ç‰Œæ•ˆæœï¼');
                Object.values(seriesEffects).forEach(effect => {
                    addLogEntry('ç³»çµ±', `âœ¨ ${effect.description}`);
                });
            }
            
            addLogEntry('ç³»çµ±', 'ğŸ’ª æº–å‚™å¥½è¿æ¥æŒ‘æˆ°äº†å—ï¼Ÿ');
            addLogEntry('ç³»çµ±', 'ğŸ“ˆ æˆ°é¬¥å‹åˆ©å¾Œï¼Œæ‰€æœ‰åƒèˆ‡æˆ°é¬¥çš„å¡ç‰Œéƒ½æœƒç²å¾—ç¶“é©—å€¼ï¼');
            
            // é–‹å§‹æ‰‹å‹•æˆ°é¬¥
            startManualBattle();
        }

        // é–‹å§‹æ‰‹å‹•æˆ°é¬¥
        function startManualBattle() {
            // é˜²å‘†åˆ¤æ–·ï¼šå¦‚æœæ²’æœ‰æ•µäººéšŠä¼ï¼Œä¸å…è¨±é–‹å§‹æ‰‹å‹•æˆ°é¬¥
            if (!gameState.enemyTeam || gameState.enemyTeam.length === 0) {
                addLogEntry('ç³»çµ±', 'âš ï¸ è«‹å…ˆé–‹å§‹æˆ°é¬¥ï¼');
                return;
            }
            
            // é˜²å‘†åˆ¤æ–·ï¼šå¦‚æœæˆ°é¬¥é‚„æ²’é–‹å§‹ï¼Œä¸å…è¨±é–‹å§‹æ‰‹å‹•æˆ°é¬¥
            if (!gameState.isBattleActive) {
                addLogEntry('ç³»çµ±', 'âš ï¸ è«‹å…ˆé–‹å§‹æˆ°é¬¥ï¼');
                return;
            }
            
            isManualBattle = true;
            currentAttacker = 0; // ç©å®¶å…ˆæ‰‹
            currentPlayerIndex = 0;
            currentEnemyIndex = 0;
            selectedEnemyIndex = -1;
            // é‡ç½®æ”»æ“Šæ¨™è¨˜
            gameState.hasAttacked = false;
            // é‡ç½®æ˜Ÿæ˜Ÿçå‹µæ¨™è¨˜
            gameState.starsAdded = false;
            document.getElementById('manual-controls').style.display = 'block';
            addLogEntry('system', 'ğŸ¯ æ‰‹å‹•æˆ°é¬¥é–‹å§‹ï¼ç©å®¶å…ˆæ‰‹');
            updateManualControls();
        }

        // æ›´æ–°æ‰‹å‹•æˆ°é¬¥æ§åˆ¶ç•Œé¢
        function updateManualControls() {
            // æ¸›å°‘æ‰€æœ‰ç©å®¶å¡ç‰‡çš„æŠ€èƒ½å†·å»
            gameState.playerTeam.forEach(card => {
                if (card.skill && card.skill.currentCooldown > 0) {
                    card.skill.currentCooldown--;
                }
            });

            const turnInfo = document.getElementById('current-turn-info');
            const attackBtn = document.getElementById('attack-btn');
            const skillBtn = document.getElementById('skill-btn');
            const defendBtn = document.getElementById('defend-btn');
            const enemySelection = document.getElementById('enemy-selection');
            const enemyTargets = document.getElementById('enemy-targets');
            
            if (!turnInfo || !attackBtn || !skillBtn || !defendBtn) return;
            
            // æª¢æŸ¥æˆ°é¬¥çµæœ
            if (gameState.enemyTeam.length === 0 || gameState.playerTeam.length === 0) {
                checkBattleResult().catch(error => {
                    console.error('æª¢æŸ¥æˆ°é¬¥çµæœæ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                });
                return;
            }
            
            if (currentAttacker === 0) {
                // ç©å®¶å›åˆ
                const player = gameState.playerTeam[currentPlayerIndex];
                turnInfo.textContent = `ç©å®¶å›åˆï¼š${player.zh} (è¡€é‡: ${Math.round(player.hp)})`;
                
                // æª¢æŸ¥æ˜¯å¦æœ‰æ•µäººå¯æ”»æ“Š
                if (gameState.enemyTeam.length > 0) {
                    attackBtn.disabled = true; // éš±è—æ”»æ“ŠæŒ‰éˆ•ï¼Œæ”¹ç‚ºç›´æ¥é»æ“Šæ•µäºº
                    
                    // æª¢æŸ¥æŠ€èƒ½æ˜¯å¦å¯ç”¨
                    const isOnCooldown = player.skill.currentCooldown > 0;
                    const attackRequirement = player.skill.attackRequirement || 0;
                    const cardLevel = player.level || 1;
                    const levelBonus = (cardLevel - 1) * 0.2;
                    const baseAttack = player.attack || 50;
                    const upgradedAttack = Math.round(baseAttack * (1 + levelBonus));
                    const hasEnoughAttack = upgradedAttack >= attackRequirement;
                    
                    skillBtn.disabled = isOnCooldown || !hasEnoughAttack;
                    defendBtn.disabled = false; // é˜²ç¦¦æŒ‰éˆ•å§‹çµ‚å¯ç”¨
                    
                    // æ›´æ–°æŠ€èƒ½æŒ‰éˆ•æ–‡å­—
                    if (isOnCooldown) {
                        skillBtn.textContent = `æŠ€èƒ½å†·å»ä¸­ (${player.skill.currentCooldown}å›åˆ)`;
                        skillBtn.title = `æŠ€èƒ½ã€Œ${player.skill.name}ã€å†·å»ä¸­ï¼Œé‚„éœ€è¦${player.skill.currentCooldown}å›åˆ`;
                    } else if (!hasEnoughAttack) {
                        skillBtn.textContent = `æŠ€èƒ½éœ€è¦æ”»æ“ŠåŠ›${attackRequirement} (ç•¶å‰${upgradedAttack})`;
                        skillBtn.title = `æŠ€èƒ½ã€Œ${player.skill.name}ã€éœ€è¦æ”»æ“ŠåŠ›${attackRequirement}ï¼Œç•¶å‰æ”»æ“ŠåŠ›${upgradedAttack}ï¼Œé‚„éœ€è¦${attackRequirement - upgradedAttack}é»æ”»æ“ŠåŠ›`;
                        
                        // æŠ€èƒ½ç„¡æ³•ä½¿ç”¨æ™‚ï¼Œç©å®¶ä»å¯ä½¿ç”¨æ™®é€šæ”»æ“Šï¼Œä¸è‡ªå‹•è·³éå›åˆ
                        addLogEntry('system', `ğŸ’¡ ${player.zh} æ”»æ“ŠåŠ›ä¸è¶³ï¼Œç„¡æ³•ä½¿ç”¨æŠ€èƒ½ï¼Œä½†å¯ä»¥ä½¿ç”¨æ™®é€šæ”»æ“Šï¼`);
                    } else {
                        skillBtn.textContent = `æŠ€èƒ½ (${player.skill.name})`;
                        skillBtn.title = `ä½¿ç”¨æŠ€èƒ½ã€Œ${player.skill.name}ã€`;
                    }
                    
                    console.log('ç©å®¶å›åˆï¼Œç›´æ¥é»æ“Šæ•µäººå¡ç‰‡é€²è¡Œæ”»æ“Š');
                    // é¡¯ç¤ºæ•µäººé¸æ“‡ç•Œé¢
                    showEnemyTargets();
                } else {
                    attackBtn.disabled = true;
                    skillBtn.disabled = true;
                    defendBtn.disabled = true;
                    if (enemySelection) enemySelection.style.display = 'none';
                }
            } else {
                // æ•µäººå›åˆ
                const enemy = gameState.enemyTeam[currentEnemyIndex];
                turnInfo.textContent = `æ•µäººå›åˆï¼š${enemy.zh} (è¡€é‡: ${Math.round(enemy.hp)})`;
                attackBtn.disabled = true;
                skillBtn.disabled = true;
                defendBtn.disabled = true;
                if (enemySelection) enemySelection.style.display = 'none';
                // æ•µäººè‡ªå‹•æ”»æ“Š
                setTimeout(() => {
                    performEnemyAttack();
                }, 1000);
            }
        }

        // é¡¯ç¤ºæ•µäººç›®æ¨™é¸æ“‡ï¼ˆç›´æ¥é»æ“Šæ•µäººå¡ç‰‡æ”»æ“Šï¼‰
        function showEnemyTargets() {
            const enemySelection = document.getElementById('enemy-selection');
            const enemyTargets = document.getElementById('enemy-targets');
            
            if (!enemySelection || !enemyTargets) return;
            
            console.log('showEnemyTargets è¢«èª¿ç”¨ï¼Œæ•µäººæ•¸é‡:', gameState.enemyTeam.length);
            
            // éš±è—é¸æ“‡ç•Œé¢ï¼Œæ”¹ç‚ºç›´æ¥é»æ“Šæ•µäººå¡ç‰‡
            enemySelection.style.display = 'none';
            
            addLogEntry('system', 'ğŸ¯ ç›´æ¥é»æ“Šæ•µäººå¡ç‰‡é€²è¡Œæ”»æ“Šï¼');
        }

        // ç›´æ¥æ”»æ“Šæ•µäºº
        async function attackEnemy(enemyIndex) {
            if (isAnimating) return; // é˜²æ­¢å‹•ç•«æœŸé–“é‡è¤‡é»æ“Š
            
            if (currentAttacker !== 0) return; // ä¸æ˜¯ç©å®¶å›åˆ
            
            // æª¢æŸ¥æ˜¯å¦å·²ç¶“æ”»æ“Šé
            if (gameState.hasAttacked) {
                addLogEntry('system', 'âš ï¸ æœ¬å›åˆå·²ç¶“æ”»æ“Šéäº†ï¼Œè«‹ç­‰å¾…ä¸‹ä¸€å›åˆï¼');
                return;
            }
            
            // ç«‹å³è¨­ç½®æ”»æ“Šæ¨™è¨˜ï¼Œé˜²æ­¢é‡è¤‡é»æ“Š
            gameState.hasAttacked = true;
            
            const player = gameState.playerTeam[currentPlayerIndex];
            const enemy = gameState.enemyTeam[enemyIndex];
            
            if (!player || !enemy) return;
            
            // æª¢æŸ¥æ•µäººæ˜¯å¦è™•æ–¼é˜²ç¦¦ç‹€æ…‹
            const isEnemyDefending = enemy.isDefending || false;
            
            // æª¢æŸ¥ç³»åˆ—æ•ˆæœ
            const seriesEffects = gameState.seriesEffects || {};
            let criticalRate = 0.15; // åŸºç¤15%æš´æ“Šç‡
            let damageBonus = 0; // å‚·å®³åŠ æˆ
            let defenseBonus = 0; // é˜²ç¦¦åŠ æˆ
            
            // è¨ˆç®—ç³»åˆ—æ•ˆæœåŠ æˆ
            Object.values(seriesEffects).forEach(effect => {
                criticalRate += effect.bonus || 0;
                damageBonus += effect.damageBonus || 0;
                defenseBonus += effect.defenseBonus || 0;
            });
            
            // è¨ˆç®—å‡ç´šå¾Œçš„æ”»æ“ŠåŠ›
            const cardLevel = player.level || 1;
            const levelBonus = (cardLevel - 1) * 0.2;
            const baseAttack = player.attack || 50;
            const upgradedAttack = Math.round(baseAttack * (1 + levelBonus));
            
            // è¨ˆç®—æ™®é€šæ”»æ“Šå‚·å®³ï¼ˆåŸºæ–¼æ”»æ“ŠåŠ›ï¼‰
            let damage = Math.floor(upgradedAttack * 1.0);
            
            // æ‡‰ç”¨å‚·å®³åŠ æˆ
            damage = Math.floor(damage * (1 + damageBonus));
            
            // æª¢æŸ¥æ˜¯å¦æš´æ“Šï¼ˆ2-5å€å‚·å®³ï¼‰
            const isCritical = Math.random() < criticalRate;
            if (isCritical) {
                // éš¨æ©Ÿæš´æ“Šå€ç‡ï¼š2-5å€
                const criticalMultiplier = 2 + Math.random() * 3; // 2.0 åˆ° 5.0
                damage = Math.floor(damage * criticalMultiplier);
                addLogEntry('player', `ğŸ’¥ æš´æ“Šå€ç‡ï¼š${criticalMultiplier.toFixed(1)}x`);
            }
            
            // å¦‚æœæ•µäººè™•æ–¼é˜²ç¦¦ç‹€æ…‹ï¼Œå‚·å®³æ¸›åŠ
            if (isEnemyDefending) {
                damage = Math.floor(damage * 0.5);
                addLogEntry('enemy', `ğŸ›¡ï¸ ${enemy.zh} è™•æ–¼é˜²ç¦¦ç‹€æ…‹ï¼Œå‚·å®³æ¸›åŠï¼`);
                await new Promise(resolve => setTimeout(resolve, 600));
            }
            
            // æ”»æ“Šæè¿°
            addLogEntry('player', `âš”ï¸ ${player.zh} æ”»æ“Š ${enemy.zh}ï¼`);
            await new Promise(resolve => setTimeout(resolve, 400));
            
            // é¡¯ç¤ºç³»åˆ—æ•ˆæœåŠ æˆ
            if (damageBonus > 0) {
                addLogEntry('player', `âœ¨ åŒç³»åˆ—åŠ æˆï¼šå‚·å®³+${Math.round(damageBonus * 100)}%`);
                await new Promise(resolve => setTimeout(resolve, 400));
            }
            
            if (isCritical) {
                addLogEntry('player', `ğŸ’¥ æš´æ“Šï¼`);
                await new Promise(resolve => setTimeout(resolve, 400));
            }
            
            // åŸ·è¡Œæ”»æ“Šå‹•ç•«
            await animateAttack(player, enemy, damage, false, isCritical);
            
            enemy.hp -= damage;
            
            addLogEntry('player', `ğŸ’¥ é€ æˆ ${damage} é»å‚·å®³ï¼`);
            await new Promise(resolve => setTimeout(resolve, 500));
            
            // æª¢æŸ¥æ•µäººæ˜¯å¦è¢«æ“Šæ•—
            if (enemy.hp <= 0) {
                addLogEntry('enemy', `ğŸ’€ ${enemy.zh} è¢«æ“Šæ•—äº†ï¼`);
                await animateDefeat(enemy, false);
                gameState.enemyTeam.splice(enemyIndex, 1);
                await new Promise(resolve => setTimeout(resolve, 300));
            }
            
            updateBattleDisplay();
            
            addLogEntry('system', 'â° æœ¬å›åˆæ”»æ“Šå®Œæˆï¼Œç­‰å¾…ä¸‹ä¸€å›åˆï¼');
            
            // åˆ‡æ›åˆ°æ•µäººå›åˆ
            await switchToEnemyTurn();
        }

        // é¸æ“‡æ•µäººç›®æ¨™ï¼ˆä¿ç•™åŸæœ‰åŠŸèƒ½ä»¥å‚™ç”¨ï¼‰
        function selectEnemyTarget(index) {
            console.log('é¸æ“‡æ•µäººç›®æ¨™:', index, 'æ•µäººåç¨±:', gameState.enemyTeam[index]?.zh);
            selectedEnemyIndex = index;
            showEnemyTargets(); // é‡æ–°é¡¯ç¤ºä»¥æ›´æ–°é«˜äº®
        }

        // åˆ‡æ›åˆ°æ•µäººå›åˆ
        async function switchToEnemyTurn() {
            currentAttacker = 1;
            selectedEnemyIndex = -1;
            document.getElementById('enemy-selection').style.display = 'none';
            
            addLogEntry('system', 'ğŸ”„ åˆ‡æ›åˆ°æ•µäººå›åˆ');
            await new Promise(resolve => setTimeout(resolve, 500));
            
            updateManualControls();
        }

        // åˆ‡æ›åˆ°ç©å®¶å›åˆ
        async function switchToPlayerTurn() {
            currentAttacker = 0;
            // æ¯å›åˆéƒ½è¦é‡æ–°é¸æ“‡
            selectedEnemyIndex = -1;
            // é‡ç½®æ”»æ“Šæ¨™è¨˜
            gameState.hasAttacked = false;
            // ç§»å‹•åˆ°ä¸‹ä¸€å€‹ç©å®¶å¡ç‰‡
            currentPlayerIndex = (currentPlayerIndex + 1) % gameState.playerTeam.length;
            // ç§»å‹•åˆ°ä¸‹ä¸€å€‹æ•µäººå¡ç‰‡
            currentEnemyIndex = (currentEnemyIndex + 1) % gameState.enemyTeam.length;
            addLogEntry('system', 'ğŸ”„ åˆ‡æ›åˆ°ç©å®¶å›åˆ');
            await new Promise(resolve => setTimeout(resolve, 500));
            updateManualControls();
        }

        // åŸ·è¡Œæ•µäººæ”»æ“Šï¼ˆåŠ å…¥æŠ€èƒ½å’Œé˜²ç¦¦æ©Ÿåˆ¶ï¼‰
        async function performEnemyAttack() {
            if (gameState.enemyTeam.length > 0 && gameState.playerTeam.length > 0) {
                const enemy = gameState.enemyTeam[currentEnemyIndex];
                const targetIndex = Math.floor(Math.random() * gameState.playerTeam.length);
                const player = gameState.playerTeam[targetIndex];
                
                // æª¢æŸ¥ç©å®¶æ˜¯å¦è™•æ–¼é˜²ç¦¦ç‹€æ…‹
                const isPlayerDefending = player.isDefending || false;
                
                // æ±ºå®šæ•µäººè¡Œå‹•ï¼ˆæ”»æ“Šã€æŠ€èƒ½ã€é˜²ç¦¦ï¼‰
                const actionType = Math.random();
                let damage = 0;
                let actionDesc = '';
                
                if (actionType < 0.6) {
                    // 60% æ©Ÿç‡æ™®é€šæ”»æ“Šï¼ˆåŸºæ–¼æ”»æ“ŠåŠ›ï¼‰
                    damage = Math.floor((enemy.attack || 40) * 1.0); // æ•µäººæ”»æ“ŠåŠ›
                    actionDesc = `âš”ï¸ ${enemy.zh} å‘ ${player.zh} ç™¼å‹•æ”»æ“Šï¼`;
                } else if (actionType < 0.8 && enemy.skill && enemy.skill.currentCooldown === 0) {
                    // 20% æ©Ÿç‡ä½¿ç”¨æŠ€èƒ½ï¼ˆåŸºæ–¼æ”»æ“ŠåŠ›ï¼‰
                    damage = Math.floor((enemy.attack || 40) * 1.5); // æ•µäººæŠ€èƒ½æ”»æ“Š1.5å€å‚·å®³
                    actionDesc = `âœ¨ ${enemy.zh} ç™¼å‹•æŠ€èƒ½ã€Œ${enemy.skill.name}ã€ï¼`;
                    enemy.skill.currentCooldown = enemy.skill.cooldown;
                } else {
                    // 20% æ©Ÿç‡é˜²ç¦¦ï¼ˆé™ä½é˜²ç¦¦æ©Ÿç‡ï¼‰
                    enemy.isDefending = true;
                    actionDesc = `ğŸ›¡ï¸ ${enemy.zh} é€²å…¥é˜²ç¦¦å§¿æ…‹ï¼`;
                    addLogEntry('enemy', actionDesc);
                    await new Promise(resolve => setTimeout(resolve, 600));
                    
                    // é˜²ç¦¦ç‹€æ…‹æŒçºŒä¸€å›åˆ
                    setTimeout(() => {
                        enemy.isDefending = false;
                    }, 2000);
                    
                    // åˆ‡æ›åˆ°ç©å®¶å›åˆ
                    await switchToPlayerTurn();
                    return;
                }
                
                // æ•µäººæš´æ“Šæª¢æŸ¥ï¼ˆ10%æ©Ÿç‡ï¼Œ2-4å€å‚·å®³ï¼‰
                const enemyCriticalRate = 0.10; // æ•µäºº10%æš´æ“Šç‡
                const isEnemyCritical = Math.random() < enemyCriticalRate;
                if (isEnemyCritical) {
                    const enemyCriticalMultiplier = 2 + Math.random() * 2; // 2.0 åˆ° 4.0
                    damage = Math.floor(damage * enemyCriticalMultiplier);
                    actionDesc += ` ğŸ’¥ æš´æ“Šï¼`;
                    addLogEntry('enemy', `ğŸ’¥ æ•µäººæš´æ“Šå€ç‡ï¼š${enemyCriticalMultiplier.toFixed(1)}x`);
                }
                
                // å¦‚æœç©å®¶è™•æ–¼é˜²ç¦¦ç‹€æ…‹ï¼Œå‚·å®³æ¸›åŠ
                if (isPlayerDefending) {
                    damage = Math.floor(damage * 0.5);
                    addLogEntry('player', `ğŸ›¡ï¸ ${player.zh} è™•æ–¼é˜²ç¦¦ç‹€æ…‹ï¼Œå‚·å®³æ¸›åŠï¼`);
                    await new Promise(resolve => setTimeout(resolve, 600));
                }
                
                // æ•µäººè¡Œå‹•æè¿°
                addLogEntry('enemy', `ğŸ‘¹ ${enemy.zh} ç™¼å‡ºå¨è„…çš„å’†å“®ï¼`);
                await new Promise(resolve => setTimeout(resolve, 600));
                
                addLogEntry('enemy', actionDesc);
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // åŸ·è¡Œæ”»æ“Šå‹•ç•«
                await animateAttack(enemy, player, damage, false, isEnemyCritical);
                
                player.hp -= damage;
                addLogEntry('enemy', `ğŸ’¥ ${enemy.zh} å° ${player.zh} é€ æˆ ${damage} é»å‚·å®³ï¼`);
                // æ’­æ”¾è¢«æ”»æ“ŠéŸ³æ•ˆ
                playWrongSound();
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // æª¢æŸ¥ç©å®¶æ˜¯å¦è¢«æ“Šæ•—
                if (player.hp <= 0) {
                    addLogEntry('player', `ğŸ’€ ${player.zh} è¢«æ“Šæ•—äº†ï¼`);
                    await animateDefeat(player, true);
                    handleDefeatedCard(player, true);
                    gameState.playerTeam.splice(targetIndex, 1);
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
                
                updateBattleDisplay();
                
                // åˆ‡æ›åˆ°ç©å®¶å›åˆ
                await switchToPlayerTurn();
            }
        }

        // ç©å®¶æ”»æ“Šï¼ˆåŠ å…¥é˜²ç¦¦æ©Ÿåˆ¶ï¼‰
        async function performPlayerAttack() {
            if (isAnimating) return; // é˜²æ­¢å‹•ç•«æœŸé–“é‡è¤‡é»æ“Š
            if (currentPlayerIndex < gameState.playerTeam.length && gameState.enemyTeam.length > 0) {
                // åªå‰©ä¸€å€‹æ•µäººè‡ªå‹•é¸
                if (selectedEnemyIndex < 0 && gameState.enemyTeam.length === 1) {
                    selectedEnemyIndex = 0;
                }
                if (selectedEnemyIndex < 0) {
                    addLogEntry('system', 'âš ï¸ è«‹å…ˆé¸æ“‡æ”»æ“Šç›®æ¨™ï¼');
                    return;
                }
                console.log('ç©å®¶æ”»æ“Šæª¢æŸ¥ - é¸æ“‡çš„æ•µäººç´¢å¼•:', selectedEnemyIndex, 'æ•µäººæ•¸é‡:', gameState.enemyTeam.length);
                
                // å¦‚æœæ²’æœ‰é¸æ“‡ç›®æ¨™ä½†åªå‰©ä¸€å€‹æ•µäººï¼Œè‡ªå‹•é¸æ“‡
                if (selectedEnemyIndex < 0 && gameState.enemyTeam.length === 1) {
                    selectedEnemyIndex = 0;
                    console.log('è‡ªå‹•é¸æ“‡æœ€å¾Œä¸€å€‹æ•µäºº');
                }
                
                if (selectedEnemyIndex >= 0) {
                    console.log('é–‹å§‹æ”»æ“Šæ•µäºº:', gameState.enemyTeam[selectedEnemyIndex]?.zh);
                    const player = gameState.playerTeam[currentPlayerIndex];
                    const enemy = gameState.enemyTeam[selectedEnemyIndex];
                    
                    // æª¢æŸ¥æ•µäººæ˜¯å¦è™•æ–¼é˜²ç¦¦ç‹€æ…‹
                    const isEnemyDefending = enemy.isDefending || false;
                    
                    // æª¢æŸ¥ç³»åˆ—æ•ˆæœ
                    const seriesEffects = gameState.seriesEffects || {};
                    let criticalRate = 0.15; // åŸºç¤15%æš´æ“Šç‡
                    let damageBonus = 0; // å‚·å®³åŠ æˆ
                    let defenseBonus = 0; // é˜²ç¦¦åŠ æˆ
                    
                    // è¨ˆç®—ç³»åˆ—æ•ˆæœåŠ æˆ
                    Object.values(seriesEffects).forEach(effect => {
                        criticalRate += effect.bonus || 0;
                        damageBonus += effect.damageBonus || 0;
                        defenseBonus += effect.defenseBonus || 0;
                    });
                    
                    // è¨ˆç®—å‡ç´šå¾Œçš„æ”»æ“ŠåŠ›
                    const cardLevel = player.level || 1;
                    const levelBonus = (cardLevel - 1) * 0.2;
                    const baseAttack = player.attack || 50;
                    const upgradedAttack = Math.round(baseAttack * (1 + levelBonus));
                    
                    // è¨ˆç®—åŸºç¤å‚·å®³ï¼ˆåŸºæ–¼æ”»æ“ŠåŠ›ï¼‰
                    let damage = upgradedAttack;
                    
                    // æ‡‰ç”¨å‚·å®³åŠ æˆ
                    damage = Math.floor(damage * (1 + damageBonus));
                    
                    // æª¢æŸ¥æ˜¯å¦æš´æ“Šï¼ˆ2-5å€å‚·å®³ï¼‰
                    const isCritical = Math.random() < criticalRate;
                    if (isCritical) {
                        // éš¨æ©Ÿæš´æ“Šå€ç‡ï¼š2-5å€
                        const criticalMultiplier = 2 + Math.random() * 3; // 2.0 åˆ° 5.0
                        damage = Math.floor(damage * criticalMultiplier);
                        addLogEntry('player', `ğŸ’¥ æš´æ“Šå€ç‡ï¼š${criticalMultiplier.toFixed(1)}x`);
                    }
                    
                    // å¦‚æœæ•µäººè™•æ–¼é˜²ç¦¦ç‹€æ…‹ï¼Œå‚·å®³æ¸›åŠ
                    if (isEnemyDefending) {
                        damage = Math.floor(damage * 0.5);
                        addLogEntry('enemy', `ğŸ›¡ï¸ ${enemy.zh} è™•æ–¼é˜²ç¦¦ç‹€æ…‹ï¼Œå‚·å®³æ¸›åŠï¼`);
                        await new Promise(resolve => setTimeout(resolve, 600));
                    }
                    
                    // æˆ°é¬¥æè¿°
                    let battleDesc = '';
                    if (isCritical) {
                        battleDesc = `ğŸ’¥ ${player.zh} ç™¼å‹•æš´æ“Šæ”»æ“Šï¼`;
                        addLogEntry('player', battleDesc);
                        await new Promise(resolve => setTimeout(resolve, 800));
                    }
                    
                    // é¡¯ç¤ºç³»åˆ—æ•ˆæœåŠ æˆ
                    if (damageBonus > 0) {
                        addLogEntry('player', `âœ¨ åŒç³»åˆ—åŠ æˆï¼šå‚·å®³+${Math.round(damageBonus * 100)}%`);
                        await new Promise(resolve => setTimeout(resolve, 400));
                    }
                    
                    battleDesc = `âš”ï¸ ${player.zh} æ®èˆæ­¦å™¨æ”»æ“Š ${enemy.zh}`;
                    addLogEntry('player', battleDesc);
                    await new Promise(resolve => setTimeout(resolve, 600));
                    
                    // åŸ·è¡Œæ”»æ“Šå‹•ç•«
                    await animateAttack(player, enemy, damage, false);
                    // æ’­æ”¾æ”»æ“ŠéŸ³æ•ˆ
                    playAttackSound();
                    
                    enemy.hp -= damage;
                    
                    // å‚·å®³æè¿°
                    const damageDesc = isCritical ? 
                        `ğŸ’¥ æš´æ“Šï¼é€ æˆ ${damage} é»å·¨å¤§å‚·å®³ï¼` : 
                        `ğŸ’¥ é€ æˆ ${damage} é»å‚·å®³ï¼`;
                    addLogEntry('player', damageDesc);
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // æª¢æŸ¥æ•µäººæ˜¯å¦è¢«æ“Šæ•—
                    if (enemy.hp <= 0) {
                        addLogEntry('enemy', `ğŸ’€ ${enemy.zh} è¢«æ“Šæ•—äº†ï¼`);
                        await animateDefeat(enemy, false);
                        gameState.enemyTeam.splice(selectedEnemyIndex, 1);
                        await new Promise(resolve => setTimeout(resolve, 300));
                    }
                    
                    updateBattleDisplay();
                    selectedEnemyIndex = -1; // é‡ç½®é¸æ“‡
                    
                    // åˆ‡æ›åˆ°æ•µäººå›åˆ
                    await switchToEnemyTurn();
                } else {
                    addLogEntry('system', 'âš ï¸ è«‹å…ˆé¸æ“‡æ”»æ“Šç›®æ¨™ï¼');
                }
            } else if (selectedEnemyIndex < 0) {
                addLogEntry('system', 'âš ï¸ è«‹å…ˆé¸æ“‡æ”»æ“Šç›®æ¨™ï¼');
            }
        }

        // å‡ç´šåŠŸèƒ½å·²ç§»é™¤ï¼Œåªèƒ½é€šéæˆ°é¬¥ç²å¾—ç¶“é©—å€¼å‡ç´š

        // ç²å–é¸ä¸­çš„å¡ç‰Œç´¢å¼•
        function getSelectedCardIndex() {
            const selectedCard = document.querySelector('.card.selected');
            if (selectedCard) {
                return parseInt(selectedCard.dataset.cardIndex);
            }
            return -1;
        }

        // é¡¯ç¤ºå¡ç‰Œè©³ç´°ä¿¡æ¯ï¼ˆåŒ…æ‹¬ç¶“é©—å€¼å’Œç´ è³ªå°æ¯”ï¼‰
        function showCardDetailInfo(card) {
            const cardLevel = card.level || 1;
            const currentExp = card.exp || 0;
            const requiredExp = getExpForNextLevel(cardLevel);
            const expProgress = Math.min(100, Math.round((currentExp / requiredExp) * 100));
            
            // è¨ˆç®—åŸºç¤ç´ è³ªå’Œå‡ç´šå¾Œç´ è³ª
            const baseAttack = card.attack || 50;
            const baseDefense = card.defense || 30;
            const baseHp = card.hp || 100;
            
            const levelBonus = (cardLevel - 1) * 0.2;
            const upgradedAttack = Math.round(baseAttack * (1 + levelBonus));
            const upgradedDefense = Math.round(baseDefense * (1 + levelBonus));
            const upgradedHp = Math.round(baseHp * (1 + levelBonus));
            
            const detailInfo = `
å¡ç‰Œè©³ç´°ä¿¡æ¯ï¼š
${card.zh}
ç­‰ç´šï¼š${cardLevel}
ç¶“é©—å€¼ï¼š${currentExp}/${requiredExp} (${expProgress}%)
ç¨€æœ‰åº¦ï¼š${card.rarity || 'æ™®é€š'}

ç´ è³ªå°æ¯”ï¼š
æ”»æ“ŠåŠ›ï¼š${baseAttack} â†’ ${upgradedAttack}
é˜²ç¦¦åŠ›ï¼š${baseDefense} â†’ ${upgradedDefense}
è¡€é‡ï¼š${baseHp} â†’ ${upgradedHp}

å‡ç´šæ–¹å¼ï¼š
åªèƒ½é€šéæˆ°é¬¥ç²å¾—ç¶“é©—å€¼è‡ªå‹•å‡ç´š

ç•¶å‰å‡ç´šæ‰€éœ€ç¶“é©—å€¼ï¼š${requiredExp}
`;
            
            alert(detailInfo);
        }

        // é‡ç½®é—œå¡
        function resetStage() {
            if (confirm('ç¢ºå®šè¦é‡ç½®é—œå¡å—ï¼Ÿé€™å°‡å›åˆ°ç¬¬1é—œï¼Œä½†ä¿ç•™æ‚¨çš„éšŠä¼ã€‚')) {
                currentStage = 1;
                stageMultiplier = 1;
                localStorage.setItem('battleStage', '1');
                
                addLogEntry('system', 'ğŸ”„ é—œå¡å·²é‡ç½®åˆ°ç¬¬1é—œï¼');
                addLogEntry('system', 'ğŸ’ª æº–å‚™é‡æ–°æŒ‘æˆ°ï¼');
                
                // é‡ç½®æˆ°é¬¥ç‹€æ…‹
                gameState.isBattleActive = false;
                gameState.enemyTeam = [];
                document.getElementById('manual-controls').style.display = 'none';
                updateBattleDisplay();
            }
        }

        // ç©å®¶é˜²ç¦¦
        async function performPlayerDefend() {
            if (isAnimating) return; // é˜²æ­¢å‹•ç•«æœŸé–“é‡è¤‡é»æ“Š
            
            if (currentPlayerIndex < gameState.playerTeam.length) {
                const player = gameState.playerTeam[currentPlayerIndex];
                
                // é€²å…¥é˜²ç¦¦ç‹€æ…‹
                player.isDefending = true;
                
                addLogEntry('player', `ğŸ›¡ï¸ ${player.zh} é€²å…¥é˜²ç¦¦å§¿æ…‹ï¼`);
                await new Promise(resolve => setTimeout(resolve, 600));
                
                addLogEntry('player', `ğŸ’ª ${player.zh} æº–å‚™æ‰¿å—ä¸‹ä¸€æ¬¡æ”»æ“Šï¼`);
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // é˜²ç¦¦ç‹€æ…‹æŒçºŒä¸€å›åˆ
                setTimeout(() => {
                    player.isDefending = false;
                    addLogEntry('player', `ğŸ”„ ${player.zh} çš„é˜²ç¦¦ç‹€æ…‹çµæŸäº†`);
                }, 2000);
                
                // åˆ‡æ›åˆ°æ•µäººå›åˆ
                await switchToEnemyTurn();
            }
        }

        // ç©å®¶ä½¿ç”¨æŠ€èƒ½ï¼ˆé­”æ³•æ”»æ“Šæ¯”æ™®é€šæ”»æ“Šå¼·ï¼‰
        async function performPlayerSkill() {
            if (isAnimating) return; // é˜²æ­¢å‹•ç•«æœŸé–“é‡è¤‡é»æ“Š
            
            // æª¢æŸ¥æ˜¯å¦å·²ç¶“æ”»æ“Šé
            if (gameState.hasAttacked) {
                addLogEntry('system', 'âš ï¸ æœ¬å›åˆå·²ç¶“æ”»æ“Šéäº†ï¼Œè«‹ç­‰å¾…ä¸‹ä¸€å›åˆï¼');
                return;
            }
            
            // ç«‹å³è¨­ç½®æ”»æ“Šæ¨™è¨˜ï¼Œé˜²æ­¢é‡è¤‡é»æ“Š
            gameState.hasAttacked = true;

            if (currentPlayerIndex < gameState.playerTeam.length && gameState.enemyTeam.length > 0) {
                // å¦‚æœæ²’æœ‰é¸æ“‡ç›®æ¨™ä½†åªå‰©ä¸€å€‹æ•µäººï¼Œè‡ªå‹•é¸æ“‡
                if (selectedEnemyIndex < 0 && gameState.enemyTeam.length === 1) {
                    selectedEnemyIndex = 0;
                }
                
                if (selectedEnemyIndex >= 0) {
                    const player = gameState.playerTeam[currentPlayerIndex];
                    const enemy = gameState.enemyTeam[selectedEnemyIndex];
                    
                    // æª¢æŸ¥æ•µäººæ˜¯å¦è™•æ–¼é˜²ç¦¦ç‹€æ…‹
                    const isEnemyDefending = enemy.isDefending || false;
                    
                    // æª¢æŸ¥ç³»åˆ—æ•ˆæœ
                    const seriesEffects = gameState.seriesEffects || {};
                    let criticalRate = 0.15; // åŸºç¤15%æš´æ“Šç‡
                    let damageBonus = 0; // å‚·å®³åŠ æˆ
                    let defenseBonus = 0; // é˜²ç¦¦åŠ æˆ
                    
                    // è¨ˆç®—ç³»åˆ—æ•ˆæœåŠ æˆ
                    Object.values(seriesEffects).forEach(effect => {
                        criticalRate += effect.bonus || 0;
                        damageBonus += effect.damageBonus || 0;
                        defenseBonus += effect.defenseBonus || 0;
                    });
                    
                    // è¨ˆç®—å‡ç´šå¾Œçš„æ”»æ“ŠåŠ›
                    const cardLevel = player.level || 1;
                    const levelBonus = (cardLevel - 1) * 0.2;
                    const baseAttack = player.attack || 50;
                    const upgradedAttack = Math.round(baseAttack * (1 + levelBonus));
                    
                    // è¨ˆç®—æŠ€èƒ½å‚·å®³ï¼ˆåŸºæ–¼æ”»æ“ŠåŠ›ï¼‰
                    let skillDamage = Math.floor(upgradedAttack * 1.8); // æŠ€èƒ½æ”»æ“Š1.8å€å‚·å®³
                    
                    // æ‡‰ç”¨å‚·å®³åŠ æˆ
                    skillDamage = Math.floor(skillDamage * (1 + damageBonus));
                    
                    // æª¢æŸ¥æ˜¯å¦æš´æ“Šï¼ˆ2-5å€å‚·å®³ï¼‰
                    const isCritical = Math.random() < criticalRate;
                    if (isCritical) {
                        // éš¨æ©Ÿæš´æ“Šå€ç‡ï¼š2-5å€
                        const criticalMultiplier = 2 + Math.random() * 3; // 2.0 åˆ° 5.0
                        skillDamage = Math.floor(skillDamage * criticalMultiplier);
                        addLogEntry('player', `ğŸ’¥ æŠ€èƒ½æš´æ“Šå€ç‡ï¼š${criticalMultiplier.toFixed(1)}x`);
                    }
                    
                    // å¦‚æœæ•µäººè™•æ–¼é˜²ç¦¦ç‹€æ…‹ï¼Œå‚·å®³æ¸›åŠ
                    if (isEnemyDefending) {
                        skillDamage = Math.floor(skillDamage * 0.5);
                        addLogEntry('enemy', `ğŸ›¡ï¸ ${enemy.zh} è™•æ–¼é˜²ç¦¦ç‹€æ…‹ï¼Œé­”æ³•å‚·å®³æ¸›åŠï¼`);
                        await new Promise(resolve => setTimeout(resolve, 600));
                    }
                    
                    // æŠ€èƒ½ç™¼å‹•æè¿°
                    addLogEntry('player', `ğŸŒŸ ${player.zh} é–‹å§‹å‡èšé­”æ³•åŠ›é‡...`);
                    await new Promise(resolve => setTimeout(resolve, 800));
                    
                    addLogEntry('player', `âœ¨ ç™¼å‹•æŠ€èƒ½ã€Œ${player.skill.name}ã€ï¼`);
                    await new Promise(resolve => setTimeout(resolve, 600));
                    
                    // é¡¯ç¤ºç³»åˆ—æ•ˆæœåŠ æˆ
                    if (damageBonus > 0) {
                        addLogEntry('player', `âœ¨ åŒç³»åˆ—åŠ æˆï¼šå‚·å®³+${Math.round(damageBonus * 100)}%`);
                        await new Promise(resolve => setTimeout(resolve, 400));
                    }
                    
                    if (isCritical) {
                        addLogEntry('player', `ğŸ’¥ æŠ€èƒ½æš´æ“Šï¼`);
                        await new Promise(resolve => setTimeout(resolve, 400));
                    }
                    
                    // åŸ·è¡ŒæŠ€èƒ½å‹•ç•«
                    await animateAttack(player, enemy, skillDamage, true, isCritical);
                    // æ’­æ”¾æŠ€èƒ½éŸ³æ•ˆ
                    playSkillSound();
                    
                    enemy.hp -= skillDamage;
                    
                    addLogEntry('player', `ğŸ’« æŠ€èƒ½ã€Œ${player.skill.name}ã€é€ æˆ ${skillDamage} é»å‚·å®³ï¼`);
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // è¨­ç½®æŠ€èƒ½å†·å»
                    player.skill.currentCooldown = player.skill.cooldown;
                    addLogEntry('system', `â° ${player.zh} çš„æŠ€èƒ½é€²å…¥å†·å»æœŸ`);
                    await new Promise(resolve => setTimeout(resolve, 300));
                    
                    // æª¢æŸ¥æ•µäººæ˜¯å¦è¢«æ“Šæ•—
                    if (enemy.hp <= 0) {
                        addLogEntry('enemy', `ğŸ’€ ${enemy.zh} è¢«æŠ€èƒ½æ“Šæ•—äº†ï¼`);
                        await animateDefeat(enemy, false);
                        gameState.enemyTeam.splice(selectedEnemyIndex, 1);
                        await new Promise(resolve => setTimeout(resolve, 300));
                    }
                    
                    updateBattleDisplay();
                    selectedEnemyIndex = -1; // é‡ç½®é¸æ“‡
                    
                    addLogEntry('system', 'â° æœ¬å›åˆæŠ€èƒ½æ”»æ“Šå®Œæˆï¼Œç­‰å¾…ä¸‹ä¸€å›åˆï¼');
                    
                    // åˆ‡æ›åˆ°æ•µäººå›åˆ
                    await switchToEnemyTurn();
                } else {
                    addLogEntry('system', 'âš ï¸ è«‹å…ˆé¸æ“‡æ”»æ“Šç›®æ¨™ï¼');
                }
            } else if (selectedEnemyIndex < 0) {
                addLogEntry('system', 'âš ï¸ è«‹å…ˆé¸æ“‡æ”»æ“Šç›®æ¨™ï¼');
            }
        }

        // æª¢æŸ¥æˆ°é¬¥çµæœ
        async function checkBattleResult() {
            if (gameState.enemyTeam.length === 0) {
                // æ’­æ”¾å‹åˆ©å‹•ç•«
                await playVictoryAnimation();
                
                addLogEntry('system', 'ğŸ‰ æˆ°é¬¥å‹åˆ©ï¼æ‰€æœ‰æ•µäººéƒ½è¢«æ“Šæ•—äº†ï¼');
                await new Promise(resolve => setTimeout(resolve, 800));
                addLogEntry('system', 'ğŸŒŸ ä½ çš„éšŠä¼å±•ç¾äº†ç„¡èˆ‡å€«æ¯”çš„å¯¦åŠ›ï¼');
                await new Promise(resolve => setTimeout(resolve, 600));
                
                // é—œå¡é€²åº¦çå‹µï¼ˆå¢åŠ çå‹µï¼‰
                const stageReward = 25 + (currentStage - 1) * 8; // å¢åŠ åŸºç¤çå‹µå’Œæ¯é—œçå‹µ
                console.log(`ç¬¬${currentStage}é—œå‹åˆ©ï¼Œæº–å‚™çµ¦äºˆ${stageReward}é¡†æ˜Ÿæ˜Ÿçå‹µ`);
                console.log('çµ¦äºˆæ˜Ÿæ˜Ÿå‰çš„æ•¸é‡:', getCurrentStars());
                addStarsToBattle(stageReward);
                console.log('çµ¦äºˆæ˜Ÿæ˜Ÿå¾Œçš„æ•¸é‡:', getCurrentStars());
                addLogEntry('system', `ğŸ’ ç²å¾—æ˜Ÿæ˜Ÿçå‹µï¼š${stageReward}é¡†ï¼`);
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // çµç®—å¡ç‰Œç¶“é©—å€¼
                await settleCardExperience(true);
                
                // é€²å…¥ä¸‹ä¸€é—œ
                currentStage++;
                localStorage.setItem('battleStage', currentStage.toString());
                stageMultiplier = 1 + (currentStage - 1) * 0.3;
                
                addLogEntry('system', `ğŸš€ æ­å–œé€šéç¬¬${currentStage - 1}é—œï¼é€²å…¥ç¬¬${currentStage}é—œï¼`);
                await new Promise(resolve => setTimeout(resolve, 800));
                addLogEntry('system', `âš ï¸ æ•µäººå°‡è®Šå¾—æ›´å¼·ï¼ç•¶å‰é—œå¡å€ç‡ï¼š${stageMultiplier.toFixed(1)}x`);
                await new Promise(resolve => setTimeout(resolve, 600));
                
                addLogEntry('system', 'ğŸ† æº–å‚™è¿æ¥æ›´æ¿€çƒˆçš„æŒ‘æˆ°ï¼');
                clearBattleArea();
                endBattle();
                return;
            }
            
            if (gameState.playerTeam.length === 0) {
                console.log('æª¢æ¸¬åˆ°æˆ°é¬¥å¤±æ•—ï¼šæ‰€æœ‰ç©å®¶å¡ç‰‡éƒ½è¢«æ“Šæ•—');
                // æ’­æ”¾å¤±æ•—å‹•ç•«
                await playDefeatAnimation();
                
                addLogEntry('system', 'ğŸ’” æˆ°é¬¥å¤±æ•—ï¼æ‰€æœ‰ç©å®¶éƒ½è¢«æ“Šæ•—äº†ï¼');
                await new Promise(resolve => setTimeout(resolve, 800));
                addLogEntry('system', `ğŸ˜” ç¬¬${currentStage}é—œçš„æ•µäººå¤ªå¼·å¤§äº†ï¼Œä¸‹æ¬¡å†ä¾†æŒ‘æˆ°å§ï¼`);
                await new Promise(resolve => setTimeout(resolve, 600));
                
                // çµç®—å¡ç‰Œç¶“é©—å€¼ï¼ˆå¤±æ•—æ™‚ï¼‰
                console.log('é–‹å§‹çµç®—å¤±æ•—æ™‚çš„ç¶“é©—å€¼...');
                await settleCardExperience(false);
                
                addLogEntry('system', 'ğŸ’ª ä¸è¦æ°£é¤’ï¼Œå¼·åŒ–ä½ çš„éšŠä¼å¾Œå†æˆ°ï¼');
                clearBattleArea();
                endBattle();
                return;
            }
        }

        // æ’­æ”¾å‹åˆ©å‹•ç•«
        async function playVictoryAnimation() {
            const battleArea = document.getElementById('battle-area');
            if (!battleArea) return;
            
            // å‰µå»ºå‹åˆ©å‹•ç•«å…ƒç´ 
            const victoryOverlay = document.createElement('div');
            victoryOverlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: linear-gradient(45deg, #ffd700, #ffed4e, #ffd700);
                z-index: 9999;
                display: flex;
                justify-content: center;
                align-items: center;
                animation: victoryPulse 2s ease-in-out;
            `;
            
            const victoryText = document.createElement('div');
            victoryText.innerHTML = `
                <div style="text-align: center; color: #fff; text-shadow: 2px 2px 4px rgba(0,0,0,0.8);">
                    <h1 style="font-size: 4rem; margin: 0; animation: victoryBounce 1s ease-in-out;">ğŸ‰ å‹åˆ©ï¼</h1>
                    <p style="font-size: 1.5rem; margin: 10px 0; animation: victoryFadeIn 1.5s ease-in-out;">æˆ°é¬¥å‹åˆ©ï¼</p>
                </div>
            `;
            
            victoryOverlay.appendChild(victoryText);
            document.body.appendChild(victoryOverlay);
            
            // æ’­æ”¾å‹åˆ©éŸ³æ•ˆ
            try {
                const victorySound = new Audio('sound/åˆå¾Œæ”¾é¬†æ™‚å…‰ï¼ˆç´”éŸ³æ¨‚ï¼‰.mp3');
                victorySound.volume = 0.6;
                victorySound.play();
            } catch (e) {
                console.log('ç„¡æ³•æ’­æ”¾å‹åˆ©éŸ³æ•ˆ');
            }
            
            // ç­‰å¾…å‹•ç•«å®Œæˆ
            await new Promise(resolve => setTimeout(resolve, 3000));
            
            // ç§»é™¤å‹•ç•«å…ƒç´ 
            if (victoryOverlay.parentNode) {
                victoryOverlay.remove();
            }
        }

        // æ’­æ”¾å¤±æ•—å‹•ç•«
        async function playDefeatAnimation() {
            const battleArea = document.getElementById('battle-area');
            if (!battleArea) return;
            
            // å‰µå»ºå¤±æ•—å‹•ç•«å…ƒç´ 
            const defeatOverlay = document.createElement('div');
            defeatOverlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: linear-gradient(45deg, #ff6b6b, #ff8e8e, #ff6b6b);
                z-index: 9999;
                display: flex;
                justify-content: center;
                align-items: center;
                animation: defeatPulse 2s ease-in-out;
            `;
            
            const defeatText = document.createElement('div');
            defeatText.innerHTML = `
                <div style="text-align: center; color: #fff; text-shadow: 2px 2px 4px rgba(0,0,0,0.8);">
                    <h1 style="font-size: 4rem; margin: 0; animation: defeatShake 1s ease-in-out;">ğŸ’” å¤±æ•—</h1>
                    <p style="font-size: 1.5rem; margin: 10px 0; animation: defeatFadeIn 1.5s ease-in-out;">æˆ°é¬¥å¤±æ•—ï¼</p>
                </div>
            `;
            
            defeatOverlay.appendChild(defeatText);
            document.body.appendChild(defeatOverlay);
            
            // æ’­æ”¾å¤±æ•—éŸ³æ•ˆ
            try {
                const defeatSound = new Audio('sound/8-bit-video-game-lose-sound-version-1-145828.mp3');
                defeatSound.volume = 0.6;
                defeatSound.play();
            } catch (e) {
                console.log('ç„¡æ³•æ’­æ”¾å¤±æ•—éŸ³æ•ˆ');
            }
            
            // ç­‰å¾…å‹•ç•«å®Œæˆ
            await new Promise(resolve => setTimeout(resolve, 3000));
            
            // ç§»é™¤å‹•ç•«å…ƒç´ 
            if (defeatOverlay.parentNode) {
                defeatOverlay.remove();
            }
        }

        // çµç®—å¡ç‰Œç¶“é©—å€¼
        async function settleCardExperience(isVictory) {
            console.log('settleCardExperience è¢«èª¿ç”¨ï¼ŒisVictory:', isVictory);
            console.log('ç•¶å‰ç©å®¶éšŠä¼æ•¸é‡:', gameState.playerTeam.length);
            console.log('åŸå§‹éšŠä¼æ•¸é‡:', gameState.originalTeam ? gameState.originalTeam.length : 'undefined');
            
            // ä½¿ç”¨åŸå§‹éšŠä¼é€²è¡Œç¶“é©—å€¼çµç®—ï¼Œç¢ºä¿æ‰€æœ‰åƒèˆ‡æˆ°é¬¥çš„å¡ç‰‡éƒ½èƒ½ç²å¾—ç¶“é©—å€¼
            const teamForExp = gameState.originalTeam || gameState.playerTeam;
            console.log('ç”¨æ–¼ç¶“é©—å€¼çµç®—çš„éšŠä¼æ•¸é‡:', teamForExp.length);
            
            if (isVictory) {
                const baseExpReward = 50 + (currentStage - 1) * 10; // åŸºç¤ç¶“é©—å€¼çå‹µ
                addLogEntry('system', `ğŸ“ˆ æˆ°é¬¥å‹åˆ©ï¼æ‰€æœ‰åƒèˆ‡æˆ°é¬¥çš„å¡ç‰Œç²å¾—ç¶“é©—å€¼ï¼`);
                await new Promise(resolve => setTimeout(resolve, 300));
                
                teamForExp.forEach((originalCard, index) => {
                    console.log(`è™•ç†ç¬¬${index + 1}å¼µåŸå§‹å¡ç‰‡:`, originalCard.zh);
                    // æ‰¾åˆ°å°æ‡‰çš„baseCard
                    let baseCard = baseCards.find(c => c.zh === originalCard.zh);
                    if (!baseCard) {
                        baseCard = baseCards.find(c => c.id === originalCard.id);
                    }
                    if (!baseCard) {
                        baseCard = baseCards.find(c => c.word === originalCard.word);
                    }
                    console.log('å‹åˆ©æ™‚å°‹æ‰¾å¡ç‰‡:', originalCard.zh, 'æ‰¾åˆ°:', baseCard ? 'æ˜¯' : 'å¦');
                    if (baseCard) {
                        // æ‰¾åˆ°å°æ‡‰çš„æˆ°é¬¥å¡ç‰‡ï¼Œæª¢æŸ¥å…¶å­˜æ´»ç‹€æ…‹
                        const battleCard = gameState.playerTeam.find(c => c.zh === originalCard.zh);
                        const survivalBonus = battleCard && battleCard.hp > 0 ? 20 : 10; // å­˜æ´»çå‹µæ›´å¤šï¼Œæ­»äº¡ä¹Ÿæœ‰çå‹µ
                        const totalExp = baseExpReward + survivalBonus;
                        console.log('å‹åˆ©æ™‚ç‚ºå¡ç‰‡', originalCard.zh, 'æ·»åŠ ç¶“é©—å€¼:', totalExp);
                        addExpToCard(baseCard, totalExp);
                    } else {
                        console.log('å‹åˆ©æ™‚æ‰¾ä¸åˆ°å°æ‡‰çš„baseCard:', originalCard.zh);
                    }
                });
            } else {
                // å¤±æ•—æ™‚ï¼Œæ‰€æœ‰å‡ºæˆ°å¡ç‰Œéƒ½èƒ½ç²å¾—ç¶“é©—å€¼
                const baseExpReward = 25 + (currentStage - 1) * 5; // æé«˜å¤±æ•—æ™‚çš„åŸºç¤ç¶“é©—å€¼
                addLogEntry('system', `ğŸ“ˆ æˆ°é¬¥å¤±æ•—ï¼æ‰€æœ‰å‡ºæˆ°å¡ç‰Œç²å¾—ç¶“é©—å€¼ï¼`);
                await new Promise(resolve => setTimeout(resolve, 300));
                
                console.log('å¤±æ•—æ™‚è™•ç†ç©å®¶éšŠä¼ï¼ŒéšŠä¼æ•¸é‡:', teamForExp.length);
                if (teamForExp.length === 0) {
                    console.log('è­¦å‘Šï¼šå¤±æ•—æ™‚æ²’æœ‰æ‰¾åˆ°åŸå§‹éšŠä¼ï¼Œä½¿ç”¨ç•¶å‰éšŠä¼');
                    // å¦‚æœæ²’æœ‰åŸå§‹éšŠä¼ï¼Œä½¿ç”¨ç•¶å‰éšŠä¼
                    const currentTeam = gameState.playerTeam;
                    currentTeam.forEach((card, index) => {
                        console.log(`è™•ç†ç¬¬${index + 1}å¼µç•¶å‰å¡ç‰‡:`, card.zh);
                        // æ‰¾åˆ°å°æ‡‰çš„baseCard
                        let baseCard = baseCards.find(c => c.zh === card.zh);
                        if (!baseCard) {
                            baseCard = baseCards.find(c => c.id === card.id);
                        }
                        if (!baseCard) {
                            baseCard = baseCards.find(c => c.word === card.word);
                        }
                        console.log('å¤±æ•—æ™‚å°‹æ‰¾å¡ç‰‡:', card.zh, 'æ‰¾åˆ°:', baseCard ? 'æ˜¯' : 'å¦');
                        if (baseCard) {
                            const survivalBonus = card.hp > 0 ? 15 : 8; // å­˜æ´»çå‹µæ›´å¤šï¼Œæ­»äº¡ä¹Ÿæœ‰çå‹µ
                            const totalExp = baseExpReward + survivalBonus;
                            console.log('å¤±æ•—æ™‚ç‚ºå¡ç‰‡', card.zh, 'æ·»åŠ ç¶“é©—å€¼:', totalExp);
                            addExpToCard(baseCard, totalExp);
                        } else {
                            console.log('å¤±æ•—æ™‚æ‰¾ä¸åˆ°å°æ‡‰çš„baseCard:', card.zh);
                        }
                    });
                } else {
                    teamForExp.forEach((originalCard, index) => {
                        console.log(`è™•ç†ç¬¬${index + 1}å¼µåŸå§‹å¡ç‰‡:`, originalCard.zh);
                        // æ‰¾åˆ°å°æ‡‰çš„baseCard
                        let baseCard = baseCards.find(c => c.zh === originalCard.zh);
                        if (!baseCard) {
                            baseCard = baseCards.find(c => c.id === originalCard.id);
                        }
                        if (!baseCard) {
                            baseCard = baseCards.find(c => c.word === originalCard.word);
                        }
                        console.log('å¤±æ•—æ™‚å°‹æ‰¾å¡ç‰‡:', originalCard.zh, 'æ‰¾åˆ°:', baseCard ? 'æ˜¯' : 'å¦');
                        if (baseCard) {
                            // æ‰¾åˆ°å°æ‡‰çš„æˆ°é¬¥å¡ç‰‡ï¼Œæª¢æŸ¥å…¶å­˜æ´»ç‹€æ…‹
                            const battleCard = gameState.playerTeam.find(c => c.zh === originalCard.zh);
                            const survivalBonus = battleCard && battleCard.hp > 0 ? 15 : 8; // å­˜æ´»çå‹µæ›´å¤šï¼Œæ­»äº¡ä¹Ÿæœ‰çå‹µ
                            const totalExp = baseExpReward + survivalBonus;
                            console.log('å¤±æ•—æ™‚ç‚ºå¡ç‰‡', originalCard.zh, 'æ·»åŠ ç¶“é©—å€¼:', totalExp);
                            addExpToCard(baseCard, totalExp);
                        } else {
                            console.log('å¤±æ•—æ™‚æ‰¾ä¸åˆ°å°æ‡‰çš„baseCard:', originalCard.zh);
                        }
                    });
                }
            }
            
            await new Promise(resolve => setTimeout(resolve, 500));
        }

        // æ¸…é™¤æˆ°é¬¥å€å¡ç‰Œ
        function clearBattleArea() {
            // æ¸…é™¤ç©å®¶éšŠä¼
            gameState.playerTeam = [];
            gameState.selectedCards.clear();
            
            // æ¸…é™¤æ•µäººéšŠä¼
            gameState.enemyTeam = [];
            
            // æ¸…é™¤åŸå§‹éšŠä¼å‰¯æœ¬
            gameState.originalTeam = null;
            
            // æ›´æ–°é¡¯ç¤º
            updateTeamDisplay();
            updateCardGrid();
            updateBattleDisplay();
            
            addLogEntry('system', 'ğŸ§¹ æˆ°é¬¥å€å·²æ¸…ç©ºï¼Œæº–å‚™ä¸‹ä¸€å ´æˆ°é¬¥ï¼');
        }

        // çµæŸæˆ°é¬¥
        function endBattle() {
            gameState.isBattleActive = false;
            isManualBattle = false;
            document.getElementById('manual-controls').style.display = 'none';
            updateCardGrid();
        }

        // è™•ç†è¢«æ“Šæ•—çš„å¡ç‰‡
        async function handleDefeatedCard(card, isPlayer) {
            if (isPlayer) {
                await animateDefeat(card, isPlayer); // æ·»åŠ æ“Šæ•—å‹•ç•«
                // å°‡è¢«æ“Šæ•—çš„å¡ç‰‡å¾éšŠä¼ä¸­ç§»é™¤
                const index = gameState.playerTeam.indexOf(card);
                if (index > -1) {
                    gameState.playerTeam.splice(index, 1);
                    console.log('å·²å°‡è¢«æ“Šæ•—çš„å¡ç‰‡å¾éšŠä¼ä¸­ç§»é™¤:', card.zh);
                    console.log('ç•¶å‰ç©å®¶éšŠä¼æ•¸é‡:', gameState.playerTeam.length);
                    addLogEntry('system', `ğŸ’” ${card.zh} è¢«æ“Šæ•—ä¸¦å¾éšŠä¼ä¸­ç§»é™¤ï¼`);
                    
                    // æª¢æŸ¥æ˜¯å¦æ‰€æœ‰ç©å®¶éƒ½è¢«æ“Šæ•—
                    if (gameState.playerTeam.length === 0) {
                        console.log('æ‰€æœ‰ç©å®¶å¡ç‰‡éƒ½è¢«æ“Šæ•—ï¼Œè§¸ç™¼å¤±æ•—æª¢æ¸¬');
                        addLogEntry('system', 'ğŸ’” æ‰€æœ‰ç©å®¶å¡ç‰‡éƒ½è¢«æ“Šæ•—ï¼');
                    }
                }
            }
        }

        // é‡ç½®æˆ°é¬¥
        function resetBattle() {
            gameState.isBattleActive = false;
            isManualBattle = false;
            gameState.enemyTeam = [];
            gameState.currentTurn = 0;
            document.getElementById('manual-controls').style.display = 'none';
            selectedEnemyIndex = -1;
            document.getElementById('enemy-selection').style.display = 'none';
            
            // æ¢å¾©ç©å®¶éšŠä¼è¡€é‡
            gameState.playerTeam.forEach(card => {
                card.hp = card.hp || 100;
                // é‡ç½®æŠ€èƒ½å†·å»
                if (card.skill) {
                    card.skill.currentCooldown = 0;
                }
            });
            
            updateBattleDisplay();
            addLogEntry('ç³»çµ±', 'æˆ°é¬¥å·²é‡ç½®');
        }

        // æ·»åŠ æ—¥èªŒæ¢ç›®
        function addLogEntry(type, message) {
            const battleLog = document.getElementById('battle-log');
            if (!battleLog) return;
            
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry ${type}`;
            logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            battleLog.appendChild(logEntry);
            battleLog.scrollTop = battleLog.scrollHeight;
        }

        // è¨­ç½®äº‹ä»¶ç›£è½å™¨
        function setupEventListeners() {
            document.getElementById('start-battle').addEventListener('click', startBattle);
            document.getElementById('manual-battle').addEventListener('click', startManualBattle);
            document.getElementById('reset-stage').addEventListener('click', resetStage);
    
            document.getElementById('attack-btn').addEventListener('click', performPlayerAttack);
            document.getElementById('skill-btn').addEventListener('click', performPlayerSkill);
            document.getElementById('defend-btn').addEventListener('click', performPlayerDefend);
            document.getElementById('skip-btn').addEventListener('click', () => {
                currentPlayerIndex++;
                updateManualControls();
            });
            document.getElementById('back-to-home').addEventListener('click', () => {
                window.location.href = 'index.html'; // è·³è½‰åˆ°é¦–é 
            });
        }



        // é é¢è¼‰å…¥å®Œæˆå¾Œåˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', () => {
            console.log('é é¢è¼‰å…¥å®Œæˆï¼Œé–‹å§‹åˆå§‹åŒ–...');
            initGame();
        });

        // é€šç”¨å½ˆçª—é—œé–‰å‡½æ•¸
        function closeModal(modalId) {
            const modal = document.getElementById(modalId);
            if (modal) {
                modal.remove();
            }
        }
        
        // é¡¯ç¤ºå¡ç‰‡è©³æƒ…Modal
        function showCardDetailModal(card) {
            // è¨ˆç®—å‡ç´šå¾Œçš„ç´ è³ª
            const cardLevel = card.level || 1;
            const levelBonus = (cardLevel - 1) * 0.2;
            const baseAttack = card.attack || 50;
            const baseDefense = card.defense || 30;
            const baseHp = card.hp || 100;
            
            const upgradedAttack = Math.round(baseAttack * (1 + levelBonus));
            const upgradedDefense = Math.round(baseDefense * (1 + levelBonus));
            const upgradedHp = Math.round(baseHp * (1 + levelBonus));
            
            // ç¶“é©—å€¼ä¿¡æ¯
            const currentExp = card.exp || 0;
            const requiredExp = getExpForNextLevel(cardLevel);
            const remainingExp = requiredExp - currentExp;
            const expProgress = Math.min(100, Math.round((currentExp / requiredExp) * 100));
            
            // ç¨€æœ‰åº¦ä¿¡æ¯
            const rarityLabel = getRarityLabel(card.rarity);
            const rarityColor = getRarityColor(card.rarity);
            
            // æŠ€èƒ½ä¿¡æ¯
            const skillInfo = card.skill ? `
                <div style="margin: 15px 0; padding: 10px; background: rgba(255,215,0,0.1); border-radius: 8px; border: 1px solid rgba(255,215,0,0.3);">
                    <div style="color: #ffd700; font-weight: bold; margin-bottom: 5px;">ğŸ¯ æŠ€èƒ½ï¼š${card.skill.name}</div>
                    <div style="color: #fff; font-size: 0.9rem; opacity: 0.9;">${card.skill.description || 'ç„¡æŠ€èƒ½æè¿°'}</div>
                    <div style="color: #4ecdc4; font-size: 0.8rem; margin-top: 5px;">å†·å»æ™‚é–“ï¼š${card.skill.cooldown || 0} å›åˆ</div>
                </div>
            ` : `
                <div style="margin: 15px 0; padding: 10px; background: rgba(150,150,150,0.1); border-radius: 8px; border: 1px solid rgba(150,150,150,0.3);">
                    <div style="color: #ccc; font-weight: bold;">âŒ ç„¡æŠ€èƒ½</div>
                </div>
            `;
            
            // å‰µå»ºModalå…§å®¹
            const modalContent = `
                <div id="card-detail-modal" style="position:fixed; z-index:9999; left:0; top:0; width:100vw; height:100vh; background:rgba(0,0,0,0.8); display:flex; align-items:center; justify-content:center;">
                    <div style="position:relative; background:rgba(20,30,40,0.98); border-radius:18px; box-shadow:0 0 32px #00ffff99; padding:30px; max-width:500px; width:90%; max-height:80vh; overflow-y:auto;">
                        <button id="close-card-detail" style="position:absolute; top:10px; right:15px; background:#222; color:#fff; border:none; border-radius:50%; width:35px; height:35px; font-size:1.5rem; cursor:pointer; z-index:10;">Ã—</button>
                        
                        <!-- å¡ç‰‡åœ–ç‰‡ -->
                        <div style="text-align:center; margin-bottom:20px;">
                            ${card.image && card.image.endsWith('.mp4') ? 
                                `<video src="${card.image}" style="width:200px;height:280px;object-fit:cover;border-radius:12px;box-shadow:0 0 20px #00ffff99;" muted autoplay loop playsinline></video>` :
                                `<img src="${card.image || 'img/card_back.jpeg'}" alt="${card.zh}" style="width:200px;height:280px;object-fit:cover;border-radius:12px;box-shadow:0 0 20px #00ffff99;">`
                            }
                        </div>
                        
                        <!-- å¡ç‰‡åç¨±å’Œç¨€æœ‰åº¦ -->
                        <div style="text-align:center; margin-bottom:20px;">
                            <div style="font-size:1.5rem; color:#ffe066; font-weight:bold; margin-bottom:10px;">${card.zh}</div>
                            <div style="display:inline-block; background:${rarityColor}; color:#fff; font-size:0.9rem; font-weight:bold; padding:5px 12px; border-radius:8px; box-shadow:0 0 8px ${rarityColor}99;">
                                ${rarityLabel}
                            </div>
                            ${cardLevel > 1 ? `<div style="display:inline-block; background:rgba(255,215,0,0.8); color:#000; font-size:0.8rem; font-weight:bold; padding:3px 8px; border-radius:6px; margin-left:10px;">Lv.${cardLevel}</div>` : ''}
                        </div>
                        
                        <!-- ç´ è³ªä¿¡æ¯ -->
                        <div style="margin:20px 0; padding:15px; background:rgba(255,107,107,0.1); border-radius:10px; border:1px solid rgba(255,107,107,0.3);">
                            <div style="color:#ff6b6b; font-weight:bold; margin-bottom:10px; font-size:1.1rem;">ğŸ’ª æˆ°é¬¥ç´ è³ª</div>
                            <div style="display:grid; grid-template-columns:1fr 1fr 1fr; gap:10px; text-align:center;">
                                <div>
                                    <div style="color:#ff6b6b; font-weight:bold; font-size:1.2rem;">${upgradedAttack}</div>
                                    <div style="color:#fff; font-size:0.8rem;">æ”»æ“ŠåŠ›</div>
                                </div>
                                <div>
                                    <div style="color:#4ecdc4; font-weight:bold; font-size:1.2rem;">${upgradedDefense}</div>
                                    <div style="color:#fff; font-size:0.8rem;">é˜²ç¦¦åŠ›</div>
                                </div>
                                <div>
                                    <div style="color:#45b7d1; font-weight:bold; font-size:1.2rem;">${upgradedHp}</div>
                                    <div style="color:#fff; font-size:0.8rem;">ç”Ÿå‘½å€¼</div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- ç­‰ç´šåŠ æˆä¿¡æ¯ -->
                        ${cardLevel > 1 ? `
                            <div style="margin:20px 0; padding:15px; background:rgba(255,215,0,0.1); border-radius:10px; border:1px solid rgba(255,215,0,0.3);">
                                <div style="color:#ffd700; font-weight:bold; margin-bottom:10px; font-size:1.1rem;">â­ ç­‰ç´šåŠ æˆ</div>
                                <div style="color:#fff; font-size:0.9rem;">
                                    ç•¶å‰ç­‰ç´šï¼š${cardLevel} (æ¯ç´šå¢åŠ 20%ç´ è³ª)<br>
                                    ç¸½åŠ æˆï¼š${Math.round(levelBonus * 100)}%
                                </div>
                            </div>
                        ` : ''}
                        
                        <!-- ç¶“é©—å€¼ä¿¡æ¯ -->
                        <div style="margin:20px 0; padding:15px; background:rgba(78,205,196,0.1); border-radius:10px; border:1px solid rgba(78,205,196,0.3);">
                            <div style="color:#4ecdc4; font-weight:bold; margin-bottom:10px; font-size:1.1rem;">ğŸ“ˆ ç¶“é©—å€¼é€²åº¦</div>
                            <div style="margin-bottom:10px;">
                                <div style="display:flex; justify-content:space-between; color:#fff; font-size:0.9rem; margin-bottom:5px;">
                                    <span>ç•¶å‰ç¶“é©—å€¼ï¼š${currentExp}</span>
                                    <span>æ‰€éœ€ç¶“é©—å€¼ï¼š${requiredExp}</span>
                                </div>
                                <div style="width:100%; height:8px; background:#333; border-radius:4px; overflow:hidden;">
                                    <div style="width:${expProgress}%; height:100%; background:linear-gradient(90deg, #4ecdc4, #45b7d1); border-radius:4px; box-shadow:0 0 6px rgba(78,205,196,0.6);"></div>
                                </div>
                            </div>
                            <div style="color:#ff6b6b; font-weight:bold; font-size:1rem;">
                                é‚„å·® ${remainingExp} ç¶“é©—å€¼å‡ç´š
                            </div>
                        </div>
                        
                        <!-- æŠ€èƒ½ä¿¡æ¯ -->
                        ${skillInfo}
                    </div>
                </div>
            `;
            
            // æ·»åŠ åˆ°é é¢
            document.body.insertAdjacentHTML('beforeend', modalContent);
            
            // æ·»åŠ é—œé–‰äº‹ä»¶
            setTimeout(() => {
                const closeBtn = document.getElementById('close-card-detail');
                if (closeBtn) {
                    closeBtn.addEventListener('click', () => {
                        closeModal('card-detail-modal');
                    });
                }
                
                // é»æ“ŠèƒŒæ™¯é—œé–‰
                const modal = document.getElementById('card-detail-modal');
                if (modal) {
                    modal.addEventListener('click', (e) => {
                        if (e.target.id === 'card-detail-modal') {
                            closeModal('card-detail-modal');
                        }
                    });
                }
            }, 100);
        }

        // é¡¯ç¤ºå¡ç‰‡æ”¾å¤§é è¦½
        function showCardPreview(card) {
            const modal = document.getElementById('card-preview-modal');
            const mediaDiv = document.getElementById('card-preview-media');
            const titleDiv = document.getElementById('card-preview-title');
            const statsDiv = document.getElementById('card-preview-stats');
            // æ¸…ç©º
            mediaDiv.innerHTML = '';
            titleDiv.textContent = card.zh || '';
            // è¨ˆç®—å‡ç´šå¾Œçš„ç´ è³ª
            const cardLevel = card.level || 1;
            const levelBonus = (cardLevel - 1) * 0.2;
            const baseAttack = card.attack || 50;
            const baseDefense = card.defense || 30;
            const baseHp = card.hp || 100;
            
            const upgradedAttack = Math.round(baseAttack * (1 + levelBonus));
            const upgradedDefense = Math.round(baseDefense * (1 + levelBonus));
            const upgradedHp = Math.round(baseHp * (1 + levelBonus));
            
            // ç¶“é©—å€¼ä¿¡æ¯
            const currentExp = card.exp || 0;
            const requiredExp = getExpForNextLevel(cardLevel);
            const remainingExp = requiredExp - currentExp;
            
            statsDiv.innerHTML = `
                <div style='margin-bottom: 8px;'>
                    <span style='color:#ff6b6b;'>æ”»:${upgradedAttack}</span>ã€€
                    <span style='color:#4ecdc4;'>é˜²:${upgradedDefense}</span>ã€€
                    <span style='color:#45b7d1;'>è¡€:${upgradedHp}</span>
                </div>
                <div style='margin-bottom: 8px;'>
                    <span style='color:#ffd700;'>ç­‰ç´š: ${cardLevel}</span>
                </div>
                <div style='margin-bottom: 8px;'>
                    <span style='color:#4ecdc4;'>ç¶“é©—å€¼: ${currentExp}/${requiredExp}</span>
                </div>
                <div style='color:#ff6b6b; font-size: 0.9rem;'>
                    é‚„å·® ${remainingExp} ç¶“é©—å€¼å‡ç´š
                </div>
            `;
            // æ”¾å¤§å…§å®¹
            if (card.image && card.image.endsWith('.mp4')) {
                mediaDiv.innerHTML = `<video src="${card.image}" style="width:160px;height:220px;object-fit:cover;border-radius:12px;box-shadow:0 0 12px #00ffff99;" muted autoplay loop playsinline></video>`;
            } else {
                const imgSrc = card.image || 'img/card_back.jpeg';
                mediaDiv.innerHTML = `<img src="${imgSrc}" alt="${card.zh}" style="width:160px;height:220px;object-fit:cover;border-radius:12px;box-shadow:0 0 12px #00ffff99;">`;
            }
            modal.style.display = 'flex';
        }

        // é—œé–‰é è¦½
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('close-card-preview').onclick = () => {
                document.getElementById('card-preview-modal').style.display = 'none';
            };
            document.getElementById('card-preview-modal').onclick = (e) => {
                if (e.target === document.getElementById('card-preview-modal')) {
                    document.getElementById('card-preview-modal').style.display = 'none';
                }
            };
        });

        // é¡¯ç¤ºå‡ç´šå°æ¯”Modal
        function showLevelUpModal(card, upgradeData) {
            const { oldLevel, newLevel, oldAttack, newAttack, oldDefense, newDefense, oldHp, newHp } = upgradeData;
            
            // è¨ˆç®—æå‡æ•¸å€¼
            const attackIncrease = newAttack - oldAttack;
            const defenseIncrease = newDefense - oldDefense;
            const hpIncrease = newHp - oldHp;
            
            // ç¨€æœ‰åº¦ä¿¡æ¯
            const rarityLabel = getRarityLabel(card.rarity);
            const rarityColor = getRarityColor(card.rarity);
            
            // å‰µå»ºModalå…§å®¹
            const modalContent = `
                <div id="levelup-modal" style="position:fixed; z-index:9999; left:0; top:0; width:100vw; height:100vh; background:rgba(0,0,0,0.9); display:flex; align-items:center; justify-content:center;">
                    <div style="position:relative; background:rgba(20,30,40,0.98); border-radius:18px; box-shadow:0 0 32px #ffd70099; padding:30px; max-width:600px; width:90%; max-height:80vh; overflow-y:auto;">
                        <button id="close-levelup-modal" style="position:absolute; top:10px; right:15px; background:#222; color:#fff; border:none; border-radius:50%; width:35px; height:35px; font-size:1.5rem; cursor:pointer; z-index:10;">Ã—</button>
                        
                        <!-- å‡ç´šæ¨™é¡Œ -->
                        <div style="text-align:center; margin-bottom:25px;">
                            <div style="font-size:2rem; color:#ffd700; font-weight:bold; margin-bottom:10px;">ğŸ‰ å‡ç´šæˆåŠŸï¼</div>
                            <div style="font-size:1.3rem; color:#ffe066; font-weight:bold;">${card.zh}</div>
                            <div style="display:inline-block; background:${rarityColor}; color:#fff; font-size:0.9rem; font-weight:bold; padding:5px 12px; border-radius:8px; box-shadow:0 0 8px ${rarityColor}99; margin-top:10px;">
                                ${rarityLabel}
                            </div>
                        </div>
                        
                        <!-- ç­‰ç´šæå‡ -->
                        <div style="text-align:center; margin-bottom:25px; padding:15px; background:rgba(255,215,0,0.1); border-radius:10px; border:1px solid rgba(255,215,0,0.3);">
                            <div style="color:#ffd700; font-weight:bold; font-size:1.2rem; margin-bottom:10px;">â­ ç­‰ç´šæå‡</div>
                            <div style="display:flex; justify-content:center; align-items:center; gap:20px;">
                                <div style="text-align:center;">
                                    <div style="color:#fff; font-size:0.9rem; margin-bottom:5px;">å‡ç´šå‰</div>
                                    <div style="color:#ffd700; font-weight:bold; font-size:1.5rem;">Lv.${oldLevel}</div>
                                </div>
                                <div style="color:#ffd700; font-size:2rem;">â†’</div>
                                <div style="text-align:center;">
                                    <div style="color:#fff; font-size:0.9rem; margin-bottom:5px;">å‡ç´šå¾Œ</div>
                                    <div style="color:#ffd700; font-weight:bold; font-size:1.5rem;">Lv.${newLevel}</div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- ç´ è³ªå°æ¯” -->
                        <div style="margin:25px 0;">
                            <div style="color:#ffd700; font-weight:bold; font-size:1.2rem; margin-bottom:15px; text-align:center;">ğŸ’ª ç´ è³ªæå‡å°æ¯”</div>
                            
                            <!-- æ”»æ“ŠåŠ›å°æ¯” -->
                            <div style="margin:15px 0; padding:15px; background:rgba(255,107,107,0.1); border-radius:10px; border:1px solid rgba(255,107,107,0.3);">
                                <div style="color:#ff6b6b; font-weight:bold; margin-bottom:10px;">âš”ï¸ æ”»æ“ŠåŠ›</div>
                                <div style="display:flex; justify-content:space-between; align-items:center;">
                                    <div style="text-align:center; flex:1;">
                                        <div style="color:#fff; font-size:0.9rem; margin-bottom:5px;">å‡ç´šå‰</div>
                                        <div style="color:#ff6b6b; font-weight:bold; font-size:1.3rem;">${oldAttack}</div>
                                    </div>
                                    <div style="color:#ff6b6b; font-size:1.5rem; margin:0 15px;">â†’</div>
                                    <div style="text-align:center; flex:1;">
                                        <div style="color:#fff; font-size:0.9rem; margin-bottom:5px;">å‡ç´šå¾Œ</div>
                                        <div style="color:#ff6b6b; font-weight:bold; font-size:1.3rem;">${newAttack}</div>
                                    </div>
                                    <div style="text-align:center; flex:1;">
                                        <div style="color:#fff; font-size:0.9rem; margin-bottom:5px;">æå‡</div>
                                        <div style="color:#4ecdc4; font-weight:bold; font-size:1.1rem;">+${attackIncrease}</div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- é˜²ç¦¦åŠ›å°æ¯” -->
                            <div style="margin:15px 0; padding:15px; background:rgba(78,205,196,0.1); border-radius:10px; border:1px solid rgba(78,205,196,0.3);">
                                <div style="color:#4ecdc4; font-weight:bold; margin-bottom:10px;">ğŸ›¡ï¸ é˜²ç¦¦åŠ›</div>
                                <div style="display:flex; justify-content:space-between; align-items:center;">
                                    <div style="text-align:center; flex:1;">
                                        <div style="color:#fff; font-size:0.9rem; margin-bottom:5px;">å‡ç´šå‰</div>
                                        <div style="color:#4ecdc4; font-weight:bold; font-size:1.3rem;">${oldDefense}</div>
                                    </div>
                                    <div style="color:#4ecdc4; font-size:1.5rem; margin:0 15px;">â†’</div>
                                    <div style="text-align:center; flex:1;">
                                        <div style="color:#fff; font-size:0.9rem; margin-bottom:5px;">å‡ç´šå¾Œ</div>
                                        <div style="color:#4ecdc4; font-weight:bold; font-size:1.3rem;">${newDefense}</div>
                                    </div>
                                    <div style="text-align:center; flex:1;">
                                        <div style="color:#fff; font-size:0.9rem; margin-bottom:5px;">æå‡</div>
                                        <div style="color:#4ecdc4; font-weight:bold; font-size:1.1rem;">+${defenseIncrease}</div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- ç”Ÿå‘½å€¼å°æ¯” -->
                            <div style="margin:15px 0; padding:15px; background:rgba(69,183,209,0.1); border-radius:10px; border:1px solid rgba(69,183,209,0.3);">
                                <div style="color:#45b7d1; font-weight:bold; margin-bottom:10px;">â¤ï¸ ç”Ÿå‘½å€¼</div>
                                <div style="display:flex; justify-content:space-between; align-items:center;">
                                    <div style="text-align:center; flex:1;">
                                        <div style="color:#fff; font-size:0.9rem; margin-bottom:5px;">å‡ç´šå‰</div>
                                        <div style="color:#45b7d1; font-weight:bold; font-size:1.3rem;">${oldHp}</div>
                                    </div>
                                    <div style="color:#45b7d1; font-size:1.5rem; margin:0 15px;">â†’</div>
                                    <div style="text-align:center; flex:1;">
                                        <div style="color:#fff; font-size:0.9rem; margin-bottom:5px;">å‡ç´šå¾Œ</div>
                                        <div style="color:#45b7d1; font-weight:bold; font-size:1.3rem;">${newHp}</div>
                                    </div>
                                    <div style="text-align:center; flex:1;">
                                        <div style="color:#fff; font-size:0.9rem; margin-bottom:5px;">æå‡</div>
                                        <div style="color:#4ecdc4; font-weight:bold; font-size:1.1rem;">+${hpIncrease}</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- ç¸½æå‡çµ±è¨ˆ -->
                        <div style="margin:25px 0; padding:15px; background:rgba(78,205,196,0.1); border-radius:10px; border:1px solid rgba(78,205,196,0.3);">
                            <div style="color:#4ecdc4; font-weight:bold; margin-bottom:10px; font-size:1.1rem;">ğŸ“Š ç¸½æå‡çµ±è¨ˆ</div>
                            <div style="color:#fff; font-size:0.9rem; line-height:1.5;">
                                <div>ğŸ¯ æ”»æ“ŠåŠ›æå‡ï¼š<span style="color:#ff6b6b; font-weight:bold;">+${attackIncrease}</span></div>
                                <div>ğŸ›¡ï¸ é˜²ç¦¦åŠ›æå‡ï¼š<span style="color:#4ecdc4; font-weight:bold;">+${defenseIncrease}</span></div>
                                <div>â¤ï¸ ç”Ÿå‘½å€¼æå‡ï¼š<span style="color:#45b7d1; font-weight:bold;">+${hpIncrease}</span></div>
                                <div style="margin-top:10px; color:#ffd700; font-weight:bold;">
                                    ç¸½æˆ°åŠ›æå‡ï¼š<span style="color:#4ecdc4;">+${attackIncrease + defenseIncrease + hpIncrease}</span>
                                </div>
                            </div>
                        </div>
                        
                        <!-- ç¢ºèªæŒ‰éˆ• -->
                        <div style="text-align:center; margin-top:25px;">
                            <button id="confirm-levelup" style="background:linear-gradient(45deg, #ffd700, #ffed4e); border:none; border-radius:10px; padding:12px 30px; color:#000; font-weight:bold; font-size:1.1rem; cursor:pointer; box-shadow:0 0 15px rgba(255,215,0,0.4);">
                                ğŸ‰ ç¢ºèªå‡ç´š
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            // æ·»åŠ åˆ°é é¢
            document.body.insertAdjacentHTML('beforeend', modalContent);
            
            // æ·»åŠ é—œé–‰äº‹ä»¶
            setTimeout(() => {
                const closeLevelupBtn = document.getElementById('close-levelup-modal');
                if (closeLevelupBtn) {
                    closeLevelupBtn.addEventListener('click', () => {
                        closeModal('levelup-modal');
                    });
                }
                
                // ç¢ºèªæŒ‰éˆ•äº‹ä»¶
                const confirmBtn = document.getElementById('confirm-levelup');
                if (confirmBtn) {
                    confirmBtn.addEventListener('click', () => {
                        closeModal('levelup-modal');
                    });
                }
                
                // é»æ“ŠèƒŒæ™¯é—œé–‰
                const levelupModal = document.getElementById('levelup-modal');
                if (levelupModal) {
                    levelupModal.addEventListener('click', (e) => {
                        if (e.target.id === 'levelup-modal') {
                            closeModal('levelup-modal');
                        }
                    });
                }
            }, 100);
        }
    </script>
</body>
</html>
