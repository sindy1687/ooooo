<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æˆ°é¬¥ç³»çµ±</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        :root {
            --glow-cyan: #00ffff;
            --glow-magenta: #ff00ff;
            --glow-yellow: #ffff00;
            --dark-blue: #0a1428;
            --medium-blue: #1a2a4a;
            --light-blue: #2a4a8a;
        }

        * {
            box-sizing: border-box;
        }

        body, html {
            width: 100vw;
            height: 100vh;
            margin: 0;
            padding: 0;
            font-family: 'Orbitron', sans-serif;
            background: linear-gradient(135deg, #0a1428 0%, #1a2a4a 50%, #0a1428 100%);
            color: #fff;
            overflow: hidden;
        }

        .main-container {
            display: grid;
            grid-template-columns: 1fr 400px;
            grid-template-rows: 1fr 300px;
            width: 100vw;
            height: 100vh;
            gap: 20px;
            padding: 20px;
        }

        /* æˆ°é¬¥å€ */
        .battle-area {
            grid-column: 1;
            grid-row: 1;
            background: rgba(10, 20, 40, 0.8);
            border: 2px solid var(--glow-magenta);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 0 20px rgba(162, 89, 255, 0.3);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            overflow-x: hidden;
        }

        .battle-field {
            flex: 1;
            background: linear-gradient(180deg, rgba(0, 0, 0, 0.5) 0%, rgba(20, 40, 80, 0.3) 100%);
            border-radius: 12px;
            position: relative;
            border: 1px solid rgba(162, 89, 255, 0.3);
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 40px 20px;
        }

        .enemy-area {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
            min-height: 120px;
        }

        .player-area {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
            min-height: 120px;
        }

        .enemy-card, .player-card {
            width: 100px;
            height: 140px;
            background: rgba(255, 0, 0, 0.2);
            border: 2px solid #ff4444;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin: 0;
            flex-shrink: 0;
            position: relative;
            overflow: hidden;
        }

        .player-card {
            background: rgba(0, 255, 0, 0.2);
            border-color: #44ff44;
        }

        .card-media {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 6px;
        }
        .card-media[is-video] {
            pointer-events: none;
        }

        .battle-controls {
            margin-top: 15px;
            text-align: center;
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .battle-btn {
            padding: 10px 20px;
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(78, 205, 196, 0.3);
            min-width: 120px;
            flex: 0 1 auto;
        }

        .battle-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 255, 255, 0.4);
        }

        /* æˆ°é¬¥æ—¥èªŒ */
        .battle-log {
            grid-column: 2;
            grid-row: 1;
            background: rgba(0, 0, 0, 0.85);
            border: 2px solid var(--glow-cyan);
            border-radius: 15px;
            padding: 20px;
            font-size: 0.9rem;
            overflow-y: auto;
            color: #fff;
            box-shadow: 0 0 12px #00ffff33;
        }

        .log-entry {
            margin-bottom: 10px;
            padding: 8px;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.1);
        }

        .log-entry.system {
            background: rgba(0, 255, 255, 0.2);
            border-left: 3px solid var(--glow-cyan);
        }

        .log-entry.player {
            background: rgba(0, 255, 0, 0.2);
            border-left: 3px solid #00ff00;
        }

        .log-entry.enemy {
            background: rgba(255, 0, 0, 0.2);
            border-left: 3px solid #ff0000;
        }

        /* ä¸‹åŠéƒ¨å€åŸŸ */
        .bottom-area {
            grid-column: 1 / span 2;
            grid-row: 2;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        /* ç·¨è¼¯éšŠä¼ */
        .team-panel {
            background: rgba(10, 20, 40, 0.8);
            border: 2px solid var(--glow-yellow);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 0 20px rgba(255, 255, 0, 0.2);
            min-height: 260px;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            overflow: visible;
        }

        .team-panel h3 {
            margin: 0 0 20px 0;
            color: var(--glow-yellow);
            text-align: center;
        }

        .team-slots {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }

        .team-slot {
            width: 80px;
            height: 110px;
            background: rgba(255, 255, 0, 0.1);
            border: 2px dashed var(--glow-yellow);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .team-slot:hover {
            background: rgba(255, 255, 0, 0.2);
            border-color: #ffff00;
        }

        .team-slot.filled {
            border-style: solid;
            background: rgba(255, 255, 0, 0.3);
        }

        .team-slot .card-media {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 6px;
        }

        .team-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 10px;
            background: rgba(255,255,0,0.08);
            border-radius: 8px;
            padding: 6px 3px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 4px;
            background: rgba(255, 255, 0, 0.13);
            border-radius: 5px;
            font-size: 0.92rem;
            font-weight: bold;
            color: #fffbe0;
        }
        .stat-label {
            color: #ffe066;
            font-size: 0.98em;
            letter-spacing: 0.5px;
        }
        .stat-value {
            color: #fff;
            font-size: 1em;
            font-weight: bold;
            text-shadow: 0 0 3px #ffe06699;
        }

        /* å¡ç‰‡é¸æ“‡å€ */
        .card-library {
            background: rgba(10, 20, 40, 0.8);
            border: 2px solid var(--glow-cyan);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
            overflow-y: auto;
        }

        .card-library h3 {
            margin: 0 0 20px 0;
            color: var(--glow-cyan);
            text-align: center;
        }

        .card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 15px;
            max-height: 200px;
            overflow-y: auto;
        }

        .card {
            width: 80px;
            height: 110px;
            background: rgba(0, 255, 255, 0.1);
            border: 2px solid var(--glow-cyan);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .card.ssr {
            background: rgba(255, 215, 0, 0.15);
            border-color: #ffd700; /* é»ƒè‰² */
            box-shadow: 0 0 8px rgba(255, 215, 0, 0.4);
        }

        .card.a {
            background: rgba(78, 205, 255, 0.15);
            border-color: #2196f3; /* è—è‰² */
            box-shadow: 0 0 6px rgba(33, 150, 243, 0.3);
        }

        .card.r {
            background: rgba(156, 39, 176, 0.15);
            border-color: #9c27b0; /* ç´«è‰² */
            box-shadow: 0 0 4px rgba(156, 39, 176, 0.2);
        }

        .card:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 255, 255, 0.4);
        }

        .card.ssr:hover {
            box-shadow: 0 5px 15px rgba(255, 215, 0, 0.6);
        }

        .card.a:hover {
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.5);
        }

        .card.r:hover {
            box-shadow: 0 5px 15px rgba(78, 205, 196, 0.4);
        }

        .card.selected {
            background: rgba(0, 255, 255, 0.3);
            border-color: #ffff00;
        }

        .card.selected::after {
            content: "å·²é¸å…¥éšŠä¼";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 0, 0.8);
            color: #000;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: bold;
        }

        .card.used {
            opacity: 0.5;
            cursor: not-allowed;
            filter: grayscale(1);
        }

        .card.used::after {
            content: "å·²ä½¿ç”¨";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.7rem;
        }

        /* è‡ªå®šç¾©æ»¾å‹•æ¢ */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--glow-cyan);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #00cccc;
        }

        /* æ‹–æ”¾æç¤º */
        .team-slot.drag-over {
            outline: 2px dashed #00ffff;
            background: rgba(0,255,255,0.2);
        }
        .card.dragging {
            opacity: 0.6;
            box-shadow: 0 0 16px #00ffff;
        }
        .player-card.ssr, .enemy-card.ssr {
            border-color: #ffd700 !important;
        }
        .player-card.a, .enemy-card.a {
            border-color: #2196f3 !important;
        }
        .player-card.r, .enemy-card.r {
            border-color: #9c27b0 !important;
        }

        /* æˆ°é¬¥å‹•ç•«æ•ˆæœ */
        @keyframes damageFloat {
            0% {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
            50% {
                transform: translateY(-20px) scale(1.2);
                opacity: 1;
            }
            100% {
                transform: translateY(-40px) scale(0.8);
                opacity: 0;
            }
        }

        @keyframes attackGlow {
            0% { box-shadow: 0 0 5px #ff6b6b; }
            50% { box-shadow: 0 0 20px #ff6b6b, 0 0 30px #ff6b6b; }
            100% { box-shadow: 0 0 5px #ff6b6b; }
        }

        @keyframes skillGlow {
            0% { box-shadow: 0 0 5px #ffd700; }
            50% { box-shadow: 0 0 25px #ffd700, 0 0 40px #ffd700; }
            100% { box-shadow: 0 0 5px #ffd700; }
        }

        @keyframes defeatShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        .battle-card {
            transition: all 0.3s ease;
        }

        .battle-card.attacking {
            animation: attackGlow 0.8s ease-in-out;
        }

        .battle-card.skill-attacking {
            animation: skillGlow 1.2s ease-in-out;
        }

        .battle-card.defeated {
            animation: defeatShake 0.5s ease-in-out;
        }

        .damage-number {
            position: absolute;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 1000;
            pointer-events: none;
        }

        .damage-number.normal {
            color: #ff6b6b;
            animation: damageFloat 1s ease-out forwards;
        }

        .damage-number.skill {
            color: #ffd700;
            animation: damageFloat 1.2s ease-out forwards;
        }

        .damage-number.critical {
            color: #ff4757;
            font-size: 1.4rem;
            animation: damageFloat 1.5s ease-out forwards;
        }
    </style>
</head>
<body>
    <!-- å¡ç‰‡æ”¾å¤§é è¦½ Modal -->
    <div id="card-preview-modal" style="display:none; position:fixed; z-index:9999; left:0; top:0; width:100vw; height:100vh; background:rgba(0,0,0,0.65); align-items:center; justify-content:center;">
        <div id="card-preview-content" style="position:relative; background:rgba(20,30,40,0.98); border-radius:18px; box-shadow:0 0 32px #00ffff99; padding:24px; display:flex; flex-direction:column; align-items:center;">
            <button id="close-card-preview" style="position:absolute; top:8px; right:12px; background:#222; color:#fff; border:none; border-radius:50%; width:32px; height:32px; font-size:1.3rem; cursor:pointer;">Ã—</button>
            <div id="card-preview-media"></div>
            <div id="card-preview-title" style="margin-top:12px; font-size:1.3rem; color:#ffe066; font-weight:bold;"></div>
            <div id="card-preview-stats" style="margin-top:8px; font-size:1.1rem; color:#fff;"></div>
        </div>
    </div>
    <div class="main-container">
        <!-- æ˜Ÿæ˜Ÿé¡¯ç¤ºå€ -->
        <div style="position: fixed; top: 20px; right: 20px; z-index: 1000; background: rgba(0,0,0,0.8); padding: 10px 15px; border-radius: 10px; border: 2px solid #ffd700; box-shadow: 0 0 10px rgba(255,215,0,0.3);">
            <div style="color: #ffd700; font-weight: bold; font-size: 1.2rem;">
                â­ <span id="totalStarsCount">0</span>
            </div>
        </div>

        <!-- è¿”å›é¦–é æŒ‰éˆ• -->
        <div style="position: fixed; top: 20px; left: 20px; z-index: 1000;">
            <button id="back-to-home" style="background: linear-gradient(45deg, #00ffff, #ff00ff); border: none; border-radius: 10px; padding: 12px 20px; color: #000; font-weight: bold; font-size: 1rem; cursor: pointer; box-shadow: 0 0 15px rgba(0,255,255,0.4); transition: all 0.3s ease;" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 5px 20px rgba(0,255,255,0.6)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 0 15px rgba(0,255,255,0.4)'">
                ğŸ  è¿”å›é¦–é 
            </button>
        </div>

        <!-- æˆ°é¬¥å€ -->
        <div class="battle-area">
            <div class="battle-field">
                <div class="enemy-area" id="enemy-area">
                    <!-- æ•µäººå¡ç‰Œæœƒåœ¨é€™è£¡é¡¯ç¤º -->
                </div>
                <div class="player-area" id="player-area">
                    <!-- ç©å®¶å¡ç‰Œæœƒåœ¨é€™è£¡é¡¯ç¤º -->
                </div>
            </div>
            <div class="battle-controls">
                <button class="battle-btn" id="start-battle">é–‹å§‹æˆ°é¬¥</button>
                <button class="battle-btn" id="manual-battle" style="background: linear-gradient(45deg, #ffd700, #ff6b6b);">æ‰‹å‹•æˆ°é¬¥</button>
            </div>
            <!-- æ‰‹å‹•æˆ°é¬¥æ§åˆ¶å€ -->
            <div id="manual-controls" style="display: none; margin-top: 15px; padding: 15px; background: rgba(0,0,0,0.3); border-radius: 10px; border: 1px solid #00ffff;">
                <div style="text-align: center; margin-bottom: 10px; color: #00ffff; font-weight: bold;">æ‰‹å‹•æˆ°é¬¥æ§åˆ¶</div>
                <div id="current-turn-info" style="text-align: center; margin-bottom: 10px; color: #fff;"></div>
                <div id="enemy-selection" style="display: none; margin-bottom: 15px; text-align: center;">
                    <div style="color: #ffd700; font-weight: bold; margin-bottom: 8px;">é¸æ“‡æ”»æ“Šç›®æ¨™ï¼š</div>
                    <div id="enemy-targets" style="display: flex; justify-content: center; gap: 10px; flex-wrap: wrap;"></div>
                </div>
                <div id="action-buttons" style="display: flex; justify-content: center; gap: 10px; flex-wrap: wrap;">
                    <button id="attack-btn" class="battle-btn" style="background: linear-gradient(45deg, #ff6b6b, #ff8e8e);">æ”»æ“Š</button>
                    <button id="skill-btn" class="battle-btn" style="background: linear-gradient(45deg, #4ecdc4, #6ee7df);">æŠ€èƒ½</button>
                    <button id="skip-btn" class="battle-btn" style="background: linear-gradient(45deg, #95a5a6, #bdc3c7);">è·³é</button>
                </div>
            </div>
        </div>

        <!-- æˆ°é¬¥æ—¥èªŒ -->
        <div class="battle-log" id="battle-log">
            <div class="log-entry system">æˆ°é¬¥ç³»çµ±å·²æº–å‚™å°±ç·’ï¼</div>
        </div>

        <!-- ä¸‹åŠéƒ¨å€åŸŸ -->
        <div class="bottom-area">
            <!-- ç·¨è¼¯éšŠä¼ -->
            <div class="team-panel">
                <h3>ç·¨è¼¯éšŠä¼</h3>
                <div class="team-slots">
                    <div class="team-slot" data-slot="0">
                        <span>æ‹–æ”¾å¡ç‰Œ</span>
                    </div>
                    <div class="team-slot" data-slot="1">
                        <span>æ‹–æ”¾å¡ç‰Œ</span>
                    </div>
                    <div class="team-slot" data-slot="2">
                        <span>æ‹–æ”¾å¡ç‰Œ</span>
                    </div>
                    <div class="team-slot" data-slot="3">
                        <span>æ‹–æ”¾å¡ç‰Œ</span>
                    </div>
                </div>
                
                <div class="team-stats">
                    <div class="stat-item">
                        <span class="stat-label">ç¸½æ”»æ“ŠåŠ›:</span>
                        <span class="stat-value" id="total-attack">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">ç¸½é˜²ç¦¦åŠ›:</span>
                        <span class="stat-value" id="total-defense">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">ç¸½ç”Ÿå‘½å€¼:</span>
                        <span class="stat-value" id="total-hp">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">éšŠä¼æŠ€èƒ½:</span>
                        <span class="stat-value" id="team-skill">ç„¡</span>
                    </div>
                </div>
            </div>

            <!-- å¡ç‰‡é¸æ“‡å€ -->
            <div class="card-library">
                <h3>å¡ç‰‡é¸æ“‡å€</h3>
                <div class="card-grid" id="card-grid">
                    <!-- å¡ç‰‡æœƒåœ¨é€™è£¡å‹•æ…‹ç”Ÿæˆ -->
                </div>
            </div>
        </div>
    </div>

    <!-- JavaScript -->
    <script src="js/sound.js"></script>
    <script src="js/soundSystem.js"></script>
    <script src="js/userData.js"></script>
    <script src="js/starRewardSystem.js"></script>
    <script src="js/cardUtils.js"></script>
    <script src="js/vocabData.js"></script>
    <script src="js/cards.js"></script>
    <script src="js/custom_cards.js"></script>
    <script src="js/achievementSystem.js"></script>
    <script>
        // éŠæˆ²ç‹€æ…‹
        // ç²å–ç•¶å‰æ˜Ÿæ˜Ÿæ•¸é‡
        function getCurrentStars() {
            console.log('getCurrentStars è¢«èª¿ç”¨');
            if (typeof StarRewardSystem !== 'undefined') {
                console.log('ä½¿ç”¨ StarRewardSystem');
                return parseInt(localStorage.getItem('totalStars') || '0');
            } else if (typeof LinkageSystem !== 'undefined' && LinkageSystem.stars) {
                console.log('ä½¿ç”¨ LinkageSystem');
                return LinkageSystem.stars.get();
            } else {
                console.log('ä½¿ç”¨ localStorage');
                return parseInt(localStorage.getItem('totalStars') || '0');
            }
        }

        // å¢åŠ æ˜Ÿæ˜Ÿï¼ˆæˆ°é¬¥ç³»çµ±å°ˆç”¨ï¼‰
        function addStarsToBattle(amount) {
            console.log('addStarsToBattle è¢«èª¿ç”¨ï¼Œæ•¸é‡:', amount);
            let currentStars = 0;
            
            if (typeof StarRewardSystem !== 'undefined') {
                console.log('ä½¿ç”¨ StarRewardSystem');
                currentStars = parseInt(localStorage.getItem('totalStars') || '0');
                const newStars = currentStars + amount;
                localStorage.setItem('totalStars', newStars.toString());
                // å˜—è©¦èª¿ç”¨ StarRewardSystem çš„æ–¹æ³•
                if (typeof StarRewardSystem.addStars === 'function') {
                    StarRewardSystem.addStars(amount);
                }
            } else if (typeof LinkageSystem !== 'undefined' && LinkageSystem.stars) {
                console.log('ä½¿ç”¨ LinkageSystem');
                currentStars = LinkageSystem.stars.get();
                LinkageSystem.stars.add(amount);
            } else {
                console.log('ä½¿ç”¨ localStorage');
                currentStars = parseInt(localStorage.getItem('totalStars') || '0');
                const newStars = currentStars + amount;
                localStorage.setItem('totalStars', newStars.toString());
            }
            
            console.log('æ˜Ÿæ˜Ÿæ›´æ–°å®Œæˆï¼Œç•¶å‰æ˜Ÿæ˜Ÿ:', getCurrentStars());
            updateStarsDisplay();
        }

        // æ›´æ–°æ˜Ÿæ˜Ÿé¡¯ç¤º
        function updateStarsDisplay() {
            const starsElement = document.getElementById('totalStarsCount');
            if (starsElement) {
                const currentStars = getCurrentStars();
                starsElement.textContent = currentStars;
                console.log('æ˜Ÿæ˜Ÿé¡¯ç¤ºå·²æ›´æ–°:', currentStars);
            }
        }

        // åˆå§‹åŒ–æ˜Ÿæ˜Ÿé¡¯ç¤º
        function initStarsDisplay() {
            updateStarsDisplay();
        }

        const gameState = {
            playerTeam: [],
            enemyTeam: [],
            isBattleActive: false,
            currentTurn: 0,
            usedCards: new Set(), // è¨˜éŒ„ä»Šå¤©è¢«æ‰“æ•—çš„å¡ç‰‡
            selectedCards: new Set() // è¨˜éŒ„å·²é¸å…¥éšŠä¼ä½†æœªä½¿ç”¨çš„å¡ç‰‡
        };

        // ç©å®¶ç‹€æ…‹
        const playerStatus = {
            coins: 1000,
            stars: 50,
            exp: 0,
            stage: 1
        };

        // åˆå§‹åŒ–éŠæˆ²
        function initGame() {
            console.log('initGame é–‹å§‹åŸ·è¡Œ');
            console.log('baseCards æ˜¯å¦å­˜åœ¨:', typeof baseCards !== 'undefined');
            console.log('baseCards é•·åº¦:', typeof baseCards !== 'undefined' ? baseCards.length : 'undefined');
            
            if (typeof baseCards === 'undefined') {
                console.log('ç­‰å¾…å¡ç‰‡è³‡æ–™è¼‰å…¥...');
                setTimeout(initGame, 100);
                return;
            }
            console.log('å¡ç‰‡è³‡æ–™å·²è¼‰å…¥ï¼Œå…±', baseCards.length, 'å¼µå¡ç‰‡');
            
            // æª¢æŸ¥å¡ç‰‡è³‡æ–™æ˜¯å¦æ­£ç¢º
            if (baseCards.length === 0) {
                console.error('å¡ç‰‡è³‡æ–™ç‚ºç©ºï¼');
                addLogEntry('ç³»çµ±', 'âŒ å¡ç‰‡è³‡æ–™è¼‰å…¥å¤±æ•—ï¼');
                return;
            }
            
            // éæ¿¾åªé¡¯ç¤ºå·²è§£é–çš„å¡ç‰‡
            filterUnlockedCards();
            
            // ç‚ºå¡ç‰‡è£œå……ç´ è³ªå±¬æ€§
            enhanceCardsWithStats();
            
            loadUsedCards();
            createCardGrid();
            setupEventListeners();
            updateTeamStats();
            initStarsDisplay();
            console.log('éŠæˆ²åˆå§‹åŒ–å®Œæˆ');
            addLogEntry('ç³»çµ±', 'éŠæˆ²åˆå§‹åŒ–å®Œæˆï¼');
        }

        // éæ¿¾åªé¡¯ç¤ºå·²è§£é–çš„å¡ç‰‡
        function filterUnlockedCards() {
            console.log('é–‹å§‹éæ¿¾å·²è§£é–çš„å¡ç‰‡...');
            
            // æª¢æŸ¥ LinkageSystem æ˜¯å¦å¯ç”¨
            if (typeof LinkageSystem === 'undefined' || !LinkageSystem.cards) {
                console.warn('LinkageSystem ä¸å¯ç”¨ï¼Œé¡¯ç¤ºæ‰€æœ‰å¡ç‰‡');
                return;
            }
            
            // ç²å–å·²è§£é–çš„å¡ç‰‡
            const ownedCards = LinkageSystem.cards.getOwnedCards();
            console.log('å·²è§£é–å¡ç‰‡æ•¸é‡:', Object.keys(ownedCards).length);
            
            // éæ¿¾ baseCardsï¼Œåªä¿ç•™å·²è§£é–çš„å¡ç‰‡
            const originalLength = baseCards.length;
            const unlockedCards = baseCards.filter(card => {
                const isUnlocked = LinkageSystem.cards.isCardOwned(card.word);
                return isUnlocked;
            });
            
            // æ›´æ–° baseCards ç‚ºå·²è§£é–çš„å¡ç‰‡
            baseCards.length = 0;
            unlockedCards.forEach(card => baseCards.push(card));
            
            console.log(`å¡ç‰‡éæ¿¾å®Œæˆï¼š${originalLength} -> ${baseCards.length} å¼µå·²è§£é–å¡ç‰‡`);
            addLogEntry('ç³»çµ±', `ğŸ“‹ å·²è¼‰å…¥ ${baseCards.length} å¼µå·²è§£é–å¡ç‰‡`);
            
            if (baseCards.length === 0) {
                console.warn('æ²’æœ‰å·²è§£é–çš„å¡ç‰‡ï¼');
                addLogEntry('ç³»çµ±', 'âš ï¸ æ²’æœ‰å·²è§£é–çš„å¡ç‰‡ï¼Œè«‹å…ˆåœ¨å¡ç‰‡æ”¶è—é é¢è§£é–å¡ç‰‡ï¼');
            }
        }

        // è¼‰å…¥ä»Šå¤©è¢«æ‰“æ•—çš„å¡ç‰‡
        function loadUsedCards() {
            const today = new Date().toDateString();
            const savedData = localStorage.getItem('usedCards_' + today);
            if (savedData) {
                gameState.usedCards = new Set(JSON.parse(savedData));
            }
        }

        // å„²å­˜ä»Šå¤©è¢«æ‰“æ•—çš„å¡ç‰‡
        function saveUsedCards() {
            const today = new Date().toDateString();
            localStorage.setItem('usedCards_' + today, JSON.stringify([...gameState.usedCards]));
        }

        // ç‚ºå¡ç‰‡è£œå……ç´ è³ªå±¬æ€§
        function enhanceCardsWithStats() {
            baseCards.forEach((card, index) => {
                // å¦‚æœå¡ç‰‡æ²’æœ‰ç´ è³ªï¼Œæ ¹æ“šç´¢å¼•ç”Ÿæˆéš¨æ©Ÿä½†å›ºå®šçš„ç´ è³ª
                if (!card.attack || !card.defense || !card.hp) {
                    const seed = index * 7 + 13; // ç°¡å–®çš„éš¨æ©Ÿç¨®å­
                    // æ ¹æ“šç¨€æœ‰åº¦è¨­å®šç´ è³ªç¯„åœ
                    const rarity = card.rarity || getRandomRarity(seed);
                    card.rarity = rarity;
                    let minStat, maxStat;
                    if (rarity === 'è¶…ç¨€æœ‰') {
                        minStat = 180; maxStat = 250; // è¶…ç¨€æœ‰ï¼š180-250
                    } else if (rarity === 'ç¨€æœ‰') {
                        minStat = 50; maxStat = 100;  // ç¨€æœ‰ï¼š50-100ï¼ˆæœ€ä½ï¼‰
                    } else {
                        minStat = 100; maxStat = 160; // æ™®é€šï¼š100-160ï¼ˆä¸­ç­‰ï¼‰
                    }
                    card.attack = card.attack || (minStat + (seed * 3 % (maxStat - minStat + 1)));
                    card.defense = card.defense || (minStat + (seed * 5 % (maxStat - minStat + 1)));
                    card.hp = card.hp || (minStat + (seed * 7 % (maxStat - minStat + 1)));
                    // ç‚ºå¡ç‰‡åŠ å…¥æŠ€èƒ½
                    if (!card.skill) {
                        card.skill = generateSkill(card, seed);
                    }
                }
            });
            console.log('å·²ç‚º', baseCards.length, 'å¼µå¡ç‰‡è£œå……ç´ è³ª');
        }

        // ç”Ÿæˆå¡ç‰‡æŠ€èƒ½
        function generateSkill(card, seed) {
            const skills = [
                { name: 'æ™®é€šæ”»æ“Š', damage: 1.0, cooldown: 0, description: 'åŸºç¤æ”»æ“Š' },
                { name: 'å¼·åŠ›ä¸€æ“Š', damage: 1.5, cooldown: 2, description: 'é€ æˆ1.5å€å‚·å®³' },
                { name: 'é˜²ç¦¦å§¿æ…‹', damage: 0.5, cooldown: 1, description: 'æ”»æ“ŠåŠ›æ¸›åŠä½†å¢åŠ é˜²ç¦¦' },
                { name: 'é€£æ“Š', damage: 0.8, cooldown: 3, description: 'é€£çºŒæ”»æ“Šå…©æ¬¡' },
                { name: 'æš´æ“Š', damage: 2.0, cooldown: 4, description: 'é€ æˆé›™å€å‚·å®³' }
            ];
            const skillIndex = seed % skills.length;
            const baseSkill = skills[skillIndex];
            
            // æ ¹æ“šç¨€æœ‰åº¦èª¿æ•´å†·å»æ™‚é–“
            let adjustedCooldown = baseSkill.cooldown;
            if (card.rarity === 'è¶…ç¨€æœ‰') {
                // SSRå¡ç‰‡å†·å»æ™‚é–“æ¸›åŠï¼ˆæœ€çŸ­ï¼‰
                adjustedCooldown = Math.max(0, Math.floor(baseSkill.cooldown * 0.5));
            } else if (card.rarity === 'ç¨€æœ‰') {
                // Aå¡ç‰‡å†·å»æ™‚é–“ç¨å¾®æ¸›å°‘
                adjustedCooldown = Math.max(0, Math.floor(baseSkill.cooldown * 0.8));
            } else {
                // æ™®é€šå¡ç‰‡ä¿æŒåŸå†·å»æ™‚é–“
                adjustedCooldown = baseSkill.cooldown;
            }
            
            return { 
                ...baseSkill, 
                cooldown: adjustedCooldown,
                currentCooldown: 0 
            };
        }

        // æˆ°é¬¥æ§åˆ¶è®Šæ•¸
        let currentAttacker = 0; // 0=ç©å®¶å›åˆ, 1=æ•µäººå›åˆ
        let currentPlayerIndex = 0;
        let currentEnemyIndex = 0;
        let isManualBattle = false;
        let isAnimating = false; // é˜²æ­¢å‹•ç•«æœŸé–“é‡è¤‡é»æ“Š
        let selectedEnemyIndex = -1; // é¸æ“‡çš„æ•µäººç´¢å¼•
        let isSelectingTarget = false; // æ˜¯å¦æ­£åœ¨é¸æ“‡ç›®æ¨™

        // æ’­æ”¾éŒ¯èª¤éŸ³æ•ˆ
        function playWrongSound() {
            try {
                // å˜—è©¦ä½¿ç”¨ç¾æœ‰çš„éŸ³æ•ˆç³»çµ±
                if (typeof playSound === 'function') {
                    playSound('wrong');
                } else if (typeof SoundSystem !== 'undefined' && SoundSystem.play) {
                    SoundSystem.play('wrong');
                } else {
                    // å‰µå»ºéŸ³æ•ˆå…ƒç´ 
                    const audio = new Audio('sound/wrong.mp3');
                    audio.volume = 0.3;
                    audio.play().catch(e => console.log('éŸ³æ•ˆæ’­æ”¾å¤±æ•—:', e));
                }
            } catch (error) {
                console.log('éŸ³æ•ˆæ’­æ”¾éŒ¯èª¤:', error);
            }
        }

        // æ’­æ”¾æ”»æ“ŠéŸ³æ•ˆ
        function playAttackSound() {
            try {
                if (typeof playSound === 'function') {
                    playSound('click');
                } else if (typeof SoundSystem !== 'undefined' && SoundSystem.play) {
                    SoundSystem.play('click');
                } else {
                    const audio = new Audio('sound/click.mp3');
                    audio.volume = 0.2;
                    audio.play().catch(e => console.log('éŸ³æ•ˆæ’­æ”¾å¤±æ•—:', e));
                }
            } catch (error) {
                console.log('éŸ³æ•ˆæ’­æ”¾éŒ¯èª¤:', error);
            }
        }

        // æ’­æ”¾æŠ€èƒ½éŸ³æ•ˆ
        function playSkillSound() {
            try {
                if (typeof playSound === 'function') {
                    playSound('correct');
                } else if (typeof SoundSystem !== 'undefined' && SoundSystem.play) {
                    SoundSystem.play('correct');
                } else {
                    const audio = new Audio('sound/correct.mp3');
                    audio.volume = 0.3;
                    audio.play().catch(e => console.log('éŸ³æ•ˆæ’­æ”¾å¤±æ•—:', e));
                }
            } catch (error) {
                console.log('éŸ³æ•ˆæ’­æ”¾éŒ¯èª¤:', error);
            }
        }

        // æˆ°é¬¥å‹•ç•«æ•ˆæœ
        function animateAttack(attacker, target, damage, isSkill = false) {
            return new Promise((resolve) => {
                isAnimating = true;
                
                // æ‰¾åˆ°æ”»æ“Šè€…å’Œç›®æ¨™çš„DOMå…ƒç´ 
                const attackerElement = document.querySelector(`[data-card-id="${attacker.originalIndex || attacker.id}"]`);
                const targetElement = document.querySelector(`[data-card-id="${target.originalIndex || target.id}"]`);
                
                // æ”»æ“Šè€…å‹•ç•«
                if (attackerElement) {
                    attackerElement.classList.add(isSkill ? 'skill-attacking' : 'attacking');
                    attackerElement.style.transform = 'scale(1.1)';
                    attackerElement.style.filter = 'brightness(1.3)';
                    
                    setTimeout(() => {
                        attackerElement.style.transform = 'scale(1)';
                        attackerElement.style.filter = 'brightness(1)';
                        attackerElement.classList.remove('attacking', 'skill-attacking');
                    }, isSkill ? 1200 : 800);
                }
                
                // ç›®æ¨™å‹•ç•«
                if (targetElement) {
                    setTimeout(() => {
                        targetElement.style.transform = 'scale(0.9)';
                        targetElement.style.filter = 'brightness(0.7)';
                        
                        // å‰µå»ºå‚·å®³æ•¸å­—
                        const damageText = document.createElement('div');
                        damageText.textContent = `-${damage}`;
                        damageText.className = `damage-number ${isSkill ? 'skill' : 'normal'}`;
                        
                        // éš¨æ©Ÿä½ç½®åç§»
                        const offsetX = (Math.random() - 0.5) * 20;
                        const offsetY = (Math.random() - 0.5) * 10;
                        damageText.style.left = `calc(50% + ${offsetX}px)`;
                        damageText.style.top = `calc(50% + ${offsetY}px)`;
                        
                        targetElement.appendChild(damageText);
                        
                        setTimeout(() => {
                            targetElement.style.transform = 'scale(1)';
                            targetElement.style.filter = 'brightness(1)';
                            damageText.remove();
                        }, isSkill ? 1200 : 1000);
                    }, isSkill ? 600 : 400);
                }
                
                setTimeout(() => {
                    isAnimating = false;
                    resolve();
                }, isSkill ? 1200 : 800);
            });
        }

        // æ“Šæ•—å‹•ç•«
        function animateDefeat(card, isPlayer) {
            return new Promise((resolve) => {
                const cardElement = document.querySelector(`[data-card-id="${card.originalIndex || card.id}"]`);
                if (cardElement) {
                    cardElement.classList.add('defeated');
                    
                    // æ“Šæ•—ç‰¹æ•ˆ
                    const defeatEffect = document.createElement('div');
                    defeatEffect.style.cssText = `
                        position: absolute;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        font-size: 2rem;
                        color: #ff4757;
                        text-shadow: 0 0 10px #ff4757;
                        z-index: 1001;
                        animation: damageFloat 1s ease-out forwards;
                    `;
                    defeatEffect.textContent = 'ğŸ’€';
                    cardElement.appendChild(defeatEffect);
                    
                    cardElement.style.transition = 'all 0.5s ease-out';
                    cardElement.style.transform = 'scale(0) rotate(180deg)';
                    cardElement.style.opacity = '0';
                    cardElement.style.filter = 'brightness(0)';
                    
                    setTimeout(() => {
                        defeatEffect.remove();
                        resolve();
                    }, 500);
                } else {
                    resolve();
                }
            });
        }

        // æ ¹æ“šç¨®å­ç”Ÿæˆç¨€æœ‰åº¦
        function getRandomRarity(seed) {
            const raritySeed = seed % 100;
            if (raritySeed < 5) return 'SSR';      // 5% æ©Ÿç‡
            else if (raritySeed < 25) return 'A';  // 20% æ©Ÿç‡
            else return 'R';                        // 75% æ©Ÿç‡
        }

        // ç¨€æœ‰åº¦è½‰æ›ï¼ˆä¸­æ–‡â†’è‹±æ–‡æ¨™ç±¤ï¼‰
        function getRarityLabel(rarity) {
            if (rarity === 'è¶…ç¨€æœ‰') return 'SSR';
            if (rarity === 'ç¨€æœ‰') return 'A';
            return 'R';
        }
        function getRarityColor(rarity) {
            if (rarity === 'è¶…ç¨€æœ‰') return '#ffd700';
            if (rarity === 'ç¨€æœ‰') return '#2196f3';
            return '#9c27b0';
        }

        // ç²å–ç¨€æœ‰åº¦èƒŒæ™¯è‰²
        function getRarityBgColor(rarity) {
            switch(rarity) {
                case 'SSR': return 'rgba(255, 215, 0, 0.2)';
                case 'A': return 'rgba(255, 107, 107, 0.2)';
                case 'R': return 'rgba(78, 205, 196, 0.2)';
                default: return 'rgba(78, 205, 196, 0.2)';
            }
        }

        // å‰µå»ºå¡ç‰‡ç¶²æ ¼
        function createCardGrid() {
            console.log('createCardGrid é–‹å§‹åŸ·è¡Œ');
            const cardGrid = document.getElementById('card-grid');
            if (!cardGrid) {
                console.error('æ‰¾ä¸åˆ° card-grid å…ƒç´ ï¼');
                return;
            }
            cardGrid.innerHTML = '';

            if (typeof baseCards === 'undefined') {
                console.log('baseCards æœªå®šç¾©ï¼Œé¡¯ç¤ºè¼‰å…¥ä¸­...');
                cardGrid.innerHTML = '<p>è¼‰å…¥ä¸­...</p>';
                return;
            }

            console.log('é–‹å§‹å‰µå»ºå¡ç‰‡ï¼Œç¸½æ•¸:', baseCards.length);
            baseCards.forEach((card, index) => {
                console.log(`å‰µå»ºå¡ç‰‡ ${index}:`, card.zh || 'ç„¡åç¨±');
                const cardDiv = createCardElement(card, index);
                cardGrid.appendChild(cardDiv);
            });
            console.log('å¡ç‰‡ç¶²æ ¼å‰µå»ºå®Œæˆ');
        }

        // å‰µå»ºå¡ç‰‡å…ƒç´ 
        function createCardElement(card, index) {
            const cardDiv = document.createElement('div');
            cardDiv.className = 'card';
            cardDiv.dataset.cardIndex = index;
            
            const isUsed = gameState.usedCards.has(index);
            const isSelected = gameState.selectedCards.has(index);
            if (isUsed) {
                cardDiv.classList.add('used');
            } else if (isSelected) {
                cardDiv.classList.add('selected');
            }

            // æ‹–æ”¾å±¬æ€§
            if (!isUsed && !isSelected) {
                cardDiv.setAttribute('draggable', 'true');
                cardDiv.addEventListener('dragstart', (e) => {
                    e.dataTransfer.setData('text/plain', index);
                    cardDiv.classList.add('dragging');
                });
                cardDiv.addEventListener('dragend', (e) => {
                    cardDiv.classList.remove('dragging');
                });
            }

            const imageSrc = card.image || 'img/card_back.jpeg';
            let mediaContent = '';
            
            if (card.image && card.image.endsWith('.mp4')) {
                mediaContent = `<video class="card-media" is-video src="${card.image}" muted preload="metadata" playsinline loop></video>`;
            } else {
                mediaContent = `<img class="card-media" src="${imageSrc}" alt="${card.zh}" onerror="this.src='img/card_back.jpeg'">`;
            }

            // ç¨€æœ‰åº¦æ¨™ç±¤
            const rarityLabel = getRarityLabel(card.rarity);
            const rarityColor = getRarityColor(card.rarity);
            const rarityTag = `<div style="position:absolute;top:3px;right:3px;background:${rarityColor};color:#fff;font-size:0.7rem;font-weight:bold;padding:2px 7px;border-radius:6px;box-shadow:0 0 6px ${rarityColor}99;z-index:2;">${rarityLabel}</div>`;

            cardDiv.innerHTML = `
                ${rarityTag}
                ${mediaContent}
                <div style="position: absolute; bottom: 0; left: 0; right: 0; background: rgba(0,0,0,0.8); padding: 3px; font-size: 0.65rem; text-align: center;">
                    <div style="font-weight: bold; margin-bottom: 2px;">${card.zh}</div>
                    <div style="display: flex; justify-content: space-between; font-size: 0.5rem; opacity: 0.9;">
                        <span style="color: #ff6b6b;">æ”»:${card.attack || 0}</span>
                        <span style="color: #4ecdc4;">é˜²:${card.defense || 0}</span>
                        <span style="color: #45b7d1;">è¡€:${card.hp || 0}</span>
                    </div>
                    <div style="font-size: 0.45rem; color: #ffd700; margin-top: 2px;">${card.skill ? card.skill.name : 'ç„¡æŠ€èƒ½'}</div>
                </div>
            `;

            // è™•ç†å½±ç‰‡æ’­æ”¾
            const video = cardDiv.querySelector('video');
            if (video) {
                cardDiv.addEventListener('mouseenter', () => {
                    if (!isSelected) video.play();
                });
                cardDiv.addEventListener('mouseleave', () => {
                    video.pause();
                    video.currentTime = 0;
                });
                video.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (!isSelected) {
                        if (video.paused) video.play();
                        else video.pause();
                    }
                });
            }

            // é»æ“Šåªå½ˆçª—ï¼Œé»å…©ä¸‹æ‰é¸å¡ï¼Œæ‹–æ”¾ä¸å½ˆçª—
            let clickTimer = null;
            cardDiv.addEventListener('click', (e) => {
                if (clickTimer) {
                    clearTimeout(clickTimer);
                    clickTimer = null;
                    // é›™æ“Šæ‰é¸å¡
                    if (!isUsed && !isSelected) selectCard(index);
                } else {
                    clickTimer = setTimeout(() => {
                        showCardPreview(card);
                        clickTimer = null;
                    }, 250);
                }
            });

            return cardDiv;
        }

        // é¸æ“‡å¡ç‰‡
        function selectCard(cardIndex) {
            if (gameState.playerTeam.length >= 4) {
                addLogEntry('ç³»çµ±', 'éšŠä¼å·²æ»¿ï¼Œç„¡æ³•æ·»åŠ æ›´å¤šå¡ç‰‡ï¼');
                return;
            }

            const card = baseCards[cardIndex];
            const slotIndex = gameState.playerTeam.length;
            
            // æ·»åŠ åˆ°éšŠä¼
            gameState.playerTeam.push({
                ...card,
                originalIndex: cardIndex
            });

            // æ¨™è¨˜ç‚ºå·²é¸å…¥éšŠä¼ï¼ˆä½†æœªä½¿ç”¨ï¼‰
            gameState.selectedCards.add(cardIndex);

            // æ›´æ–°UI
            updateTeamDisplay();
            updateCardGrid();
            updateTeamStats();
            
            addLogEntry('ç³»çµ±', `å·²é¸æ“‡å¡ç‰‡ï¼š${card.zh}`);
        }

        // æ›´æ–°éšŠä¼é¡¯ç¤º
        function updateTeamDisplay() {
            const teamSlots = document.querySelectorAll('.team-slot');
            
            teamSlots.forEach((slot, index) => {
                slot.innerHTML = '';
                slot.setAttribute('data-slot', index);
                slot.classList.remove('drag-over');
                // æ‹–æ”¾äº‹ä»¶
                slot.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    slot.classList.add('drag-over');
                });
                slot.addEventListener('dragleave', (e) => {
                    slot.classList.remove('drag-over');
                });
                slot.addEventListener('drop', (e) => {
                    e.preventDefault();
                    slot.classList.remove('drag-over');
                    const cardIndex = parseInt(e.dataTransfer.getData('text/plain'));
                    if (!gameState.usedCards.has(cardIndex)) {
                        dropCardToSlot(cardIndex, index);
                    }
                });
                
                if (index < gameState.playerTeam.length) {
                    const card = gameState.playerTeam[index];
                    const imageSrc = card.image || 'img/card_back.jpeg';
                    
                    let mediaContent = '';
                    if (card.image && card.image.endsWith('.mp4')) {
                        mediaContent = `<video class="card-media" is-video src="${card.image}" muted preload="metadata" playsinline loop></video>`;
                    } else {
                        mediaContent = `<img class="card-media" src="${imageSrc}" alt="${card.zh}" onerror="this.src='img/card_back.jpeg'">`;
                    }
                    // ç¨€æœ‰åº¦æ¨™ç±¤
                    const rarityLabel = getRarityLabel(card.rarity);
                    const rarityColor = getRarityColor(card.rarity);
                    const rarityTag = `<div style="position:absolute;top:3px;right:3px;background:${rarityColor};color:#fff;font-size:0.7rem;font-weight:bold;padding:2px 7px;border-radius:6px;box-shadow:0 0 6px ${rarityColor}99;z-index:2;">${rarityLabel}</div>`;
                    
                    // åˆ¤æ–·æ˜¯å¦é–å®šï¼ˆè¢«æ‰“æ•—ï¼‰
                    const isLocked = card.originalIndex !== undefined && gameState.usedCards.has(card.originalIndex);
                    let lockTag = '';
                    if (isLocked) {
                        lockTag = `<div style="position:absolute;left:3px;top:3px;background:rgba(0,0,0,0.7);color:#ffd700;font-size:0.8rem;font-weight:bold;padding:2px 6px;border-radius:6px;z-index:3;display:flex;align-items:center;"><span style='font-size:1.1em;margin-right:2px;'>ğŸ”’</span>é–å®š</div>`;
                    }
                    slot.innerHTML = `
                        ${rarityTag}
                        ${lockTag}
                        ${mediaContent}
                        <div style="position: absolute; bottom: 0; left: 0; right: 0; background: rgba(0,0,0,0.8); padding: 3px; font-size: 0.65rem; text-align: center;">
                            <div style="font-weight: bold; margin-bottom: 2px;">${card.zh}</div>
                            <div style="display: flex; justify-content: space-between; font-size: 0.5rem; opacity: 0.9;">
                                <span style="color: #ff6b6b;">æ”»:${card.attack || 0}</span>
                                <span style="color: #4ecdc4;">é˜²:${card.defense || 0}</span>
                                <span style="color: #45b7d1;">è¡€:${card.hp || 0}</span>
                            </div>
                            <div style="font-size: 0.45rem; color: #ffd700; margin-top: 2px;">${card.skill ? card.skill.name : 'ç„¡æŠ€èƒ½'}</div>
                        </div>
                    `;
                    slot.classList.add('filled');
                    if (isLocked) {
                        slot.style.opacity = '0.5';
                        slot.style.pointerEvents = 'none';
                        slot.style.filter = 'grayscale(0.7) blur(1px)';
                    } else {
                        slot.style.opacity = '1';
                        slot.style.pointerEvents = '';
                        slot.style.filter = '';
                        // æ·»åŠ é›™æ“Šç§»é™¤å¡ç‰‡åŠŸèƒ½
                        slot.addEventListener('dblclick', () => {
                            removeCardFromSlot(index);
                        });
                    }
                    // è™•ç†å½±ç‰‡æ’­æ”¾
                    const video = slot.querySelector('video');
                    if (video) {
                        slot.addEventListener('mouseenter', () => video.play());
                        slot.addEventListener('mouseleave', () => {
                            video.pause();
                            video.currentTime = 0;
                        });
                    }
                } else {
                    slot.innerHTML = '<span>æ‹–æ”¾å¡ç‰Œ</span>';
                    slot.classList.remove('filled');
                }
            });
        }

        // æ‹–æ”¾åˆ°éšŠä¼æ¬„ä½çš„é‚è¼¯
        function dropCardToSlot(cardIndex, slotIndex) {
            // å…ˆæª¢æŸ¥è©²å¡ç‰‡æ˜¯å¦å·²ç¶“åœ¨éšŠä¼ä¸­
            const alreadyInTeam = gameState.playerTeam.some(c => c.originalIndex === cardIndex);
            if (alreadyInTeam) return;
            // æª¢æŸ¥è©²å¡ç‰‡æ˜¯å¦å·²ç¶“è¢«ä½¿ç”¨ï¼ˆæˆ°é¬¥å¾Œï¼‰
            if (gameState.usedCards.has(cardIndex)) return;
            
            // å–å¾—å¡ç‰‡è³‡æ–™
            const card = baseCards[cardIndex];
            const cardData = {
                ...card,
                hp: card.hp || 100,
                attack: card.attack || 0,
                defense: card.defense || 0,
                originalIndex: cardIndex
            };
            // å¦‚æœè©²æ¬„ä½å·²ç¶“æœ‰å¡ç‰‡ï¼Œè¦†è“‹
            if (slotIndex < gameState.playerTeam.length) {
                gameState.playerTeam[slotIndex] = cardData;
            } else {
                // å¦‚æœè©²æ¬„ä½æ˜¯ç©ºçš„ï¼Œç›´æ¥æ”¾é€²å»
                gameState.playerTeam.push(cardData);
            }
            // æ¨™è¨˜ç‚ºå·²é¸å…¥éšŠä¼ï¼ˆä½†æœªä½¿ç”¨ï¼‰
            gameState.selectedCards.add(cardIndex);
            updateTeamDisplay();
            updateCardGrid();
            updateTeamStats();
            addLogEntry('ç³»çµ±', `æ‹–æ”¾å¡ç‰‡ï¼š${card.zh}`);
        }

        // ç§»é™¤å¡ç‰‡å¾éšŠä¼æ¬„ä½
        function removeCardFromSlot(slotIndex) {
            if (slotIndex >= gameState.playerTeam.length) return;

            const removedCard = gameState.playerTeam.splice(slotIndex, 1)[0];
            gameState.selectedCards.delete(removedCard.originalIndex);
            updateTeamDisplay();
            updateCardGrid();
            updateTeamStats();
            addLogEntry('ç³»çµ±', `ç§»é™¤å¡ç‰‡ï¼š${removedCard.zh}`);
        }

        // æ›´æ–°å¡ç‰‡ç¶²æ ¼
        function updateCardGrid() {
            const cards = document.querySelectorAll('.card');
            cards.forEach((cardDiv, index) => {
                const isSelected = gameState.selectedCards.has(index);
                const isUsed = gameState.usedCards.has(index);
                cardDiv.classList.remove('used', 'selected', 'ssr', 'a', 'r');
                if (isUsed) {
                    cardDiv.classList.add('used');
                } else if (isSelected) {
                    cardDiv.classList.add('selected');
                }
                // æ ¹æ“šç¨€æœ‰åº¦è¨­å®šèƒŒæ™¯å’Œé‚Šæ¡†é¡è‰²
                if (baseCards[index] && baseCards[index].rarity) {
                    cardDiv.classList.add(baseCards[index].rarity.toLowerCase());
                }
            });
        }

        // æ›´æ–°éšŠä¼çµ±è¨ˆ
        function updateTeamStats() {
            let totalAttack = 0;
            let totalDefense = 0;
            let totalHp = 0;
            
            gameState.playerTeam.forEach(card => {
                totalAttack += card.attack || 0;
                totalDefense += card.defense || 0;
                totalHp += card.hp || 0;
            });

            document.getElementById('total-attack').textContent = totalAttack;
            document.getElementById('total-defense').textContent = totalDefense;
            document.getElementById('total-hp').textContent = totalHp;
            document.getElementById('team-skill').textContent = gameState.playerTeam.length > 0 ? 'å·²å•Ÿç”¨' : 'ç„¡';
        }

        // ç”Ÿæˆæ•µäººéšŠä¼
        function generateEnemyTeam() {
            const enemyCount = 4;
            gameState.enemyTeam = [];
            for (let i = 0; i < enemyCount; i++) {
                const randomCard = baseCards[Math.floor(Math.random() * baseCards.length)];
                gameState.enemyTeam.push({
                    ...randomCard,
                    hp: (randomCard.hp || 100) * 1.2,
                    maxHp: (randomCard.hp || 100) * 1.2
                });
            }
            console.log('ç”Ÿæˆæ•µäººéšŠä¼ï¼š', gameState.enemyTeam.length, 'å€‹æ•µäºº');
        }

        // æ›´æ–°æˆ°é¬¥é¡¯ç¤º
        function updateBattleDisplay() {
            const enemyArea = document.getElementById('enemy-area');
            const playerArea = document.getElementById('player-area');
            
            // æ¸…ç©ºå€åŸŸ
            enemyArea.innerHTML = '';
            playerArea.innerHTML = '';
            
            // é¡¯ç¤ºæ•µäººå¡ç‰Œ
            gameState.enemyTeam.forEach((enemy, index) => {
                const enemyCard = createBattleCardElement(enemy, 'enemy', index);
                enemyArea.appendChild(enemyCard);
            });
            
            // é¡¯ç¤ºç©å®¶å¡ç‰Œ
            gameState.playerTeam.forEach((card, index) => {
                const playerCard = createBattleCardElement(card, 'player', index);
                playerArea.appendChild(playerCard);
            });
            
            console.log('æ›´æ–°æˆ°é¬¥é¡¯ç¤ºï¼š', gameState.enemyTeam.length, 'å€‹æ•µäººï¼Œ', gameState.playerTeam.length, 'å€‹ç©å®¶');
        }

        // å‰µå»ºæˆ°é¬¥å¡ç‰‡å…ƒç´ 
        function createBattleCardElement(card, type, index) {
            const cardDiv = document.createElement('div');
            cardDiv.className = type === 'enemy' ? 'enemy-card' : 'player-card';
            cardDiv.dataset.index = index;
            cardDiv.dataset.cardId = card.originalIndex || card.id || `battle-${type}-${index}`;
            // æ–°å¢ç¨€æœ‰åº¦ class
            if (card.rarity) {
                cardDiv.classList.add(card.rarity.toLowerCase());
            }
            
            const imageSrc = card.image || 'img/card_back.jpeg';
            let mediaContent = '';
            
            if (card.image && card.image.endsWith('.mp4')) {
                mediaContent = `<video class="card-media" is-video src="${card.image}" muted preload="metadata" playsinline loop></video>`;
            } else {
                mediaContent = `<img class="card-media" src="${imageSrc}" alt="${card.zh}" onerror="this.src='img/card_back.jpeg'">`;
            }
            // ç¨€æœ‰åº¦æ¨™ç±¤
            const rarityLabel = getRarityLabel(card.rarity);
            const rarityColor = getRarityColor(card.rarity);
            const rarityTag = `<div style="position:absolute;top:3px;right:3px;background:${rarityColor};color:#fff;font-size:0.7rem;font-weight:bold;padding:2px 7px;border-radius:6px;box-shadow:0 0 6px ${rarityColor}99;z-index:2;">${rarityLabel}</div>`;

            // è¡€æ¢
            const hp = Math.round(card.hp || 100);
            const maxHp = Math.round(card.maxHp || card.hp || 100);
            const hpPercent = Math.max(0, Math.min(100, Math.round((hp / maxHp) * 100)));
            const hpBar = `<div style="width: 90%; height: 10px; background: #222; border-radius: 5px; margin: 2px auto 0 auto; position: relative;">
                <div style="width: ${hpPercent}%; height: 100%; background: linear-gradient(90deg, #ff6b6b, #ffe066); border-radius: 5px;"></div>
                <span style="position: absolute; left: 50%; top: 50%; transform: translate(-50%,-50%); font-size: 0.65em; color: #fff; text-shadow: 0 0 2px #000;">${hp}/${maxHp}</span>
            </div>`;

            cardDiv.innerHTML = `
                ${rarityTag}
                ${mediaContent}
                <div style="position: absolute; bottom: 0; left: 0; right: 0; background: rgba(0,0,0,0.8); padding: 4px; font-size: 0.8rem; text-align: center;">
                    <div>${card.zh}</div>
                    ${hpBar}
                    <div style="font-size: 0.6rem; color: #ffd700; margin-top: 2px;">${card.skill ? card.skill.name : 'ç„¡æŠ€èƒ½'}</div>
                </div>
            `;

            // è™•ç†å½±ç‰‡æ’­æ”¾
            const video = cardDiv.querySelector('video');
            if (video) {
                cardDiv.addEventListener('mouseenter', () => video.play());
                cardDiv.addEventListener('mouseleave', () => {
                    video.pause();
                    video.currentTime = 0;
                });
                video.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (video.paused) video.play();
                    else video.pause();
                });
            }

            return cardDiv;
        }

        // é–‹å§‹æˆ°é¬¥
        async function startBattle() {
            if (gameState.playerTeam.length === 0) {
                addLogEntry('ç³»çµ±', 'è«‹å…ˆé¸æ“‡å¡ç‰‡çµ„æˆéšŠä¼ï¼');
                return;
            }

            if (gameState.isBattleActive) {
                addLogEntry('ç³»çµ±', 'æˆ°é¬¥æ­£åœ¨é€²è¡Œä¸­ï¼');
                return;
            }

            // æª¢æŸ¥æ˜Ÿæ˜Ÿæ•¸é‡
            const currentStars = getCurrentStars();
            console.log('ç•¶å‰æ˜Ÿæ˜Ÿæ•¸é‡:', currentStars);
            if (currentStars < 10) {
                addLogEntry('ç³»çµ±', 'æ˜Ÿæ˜Ÿä¸è¶³ï¼éœ€è¦10é¡†æ˜Ÿæ˜Ÿæ‰èƒ½é–‹å§‹æˆ°é¬¥ã€‚');
                return;
            }
            // æ‰£é™¤10é¡†æ˜Ÿæ˜Ÿ
            addStarsToBattle(-10);
            console.log('å·²æ‰£é™¤10é¡†æ˜Ÿæ˜Ÿï¼Œç•¶å‰æ˜Ÿæ˜Ÿ:', getCurrentStars());
            addLogEntry('ç³»çµ±', 'ğŸ’ æ¶ˆè€—10é¡†æ˜Ÿæ˜Ÿé–‹å§‹æˆ°é¬¥ï¼');
            await new Promise(resolve => setTimeout(resolve, 500));
            addLogEntry('ç³»çµ±', 'âš”ï¸ æˆ°é¬¥å³å°‡é–‹å§‹...');
            await new Promise(resolve => setTimeout(resolve, 600));
            addLogEntry('ç³»çµ±', 'ğŸ”¥ æ•µäººæ­£åœ¨é€¼è¿‘ï¼');
            await new Promise(resolve => setTimeout(resolve, 500));

            // æˆ°é¬¥é–‹å§‹æ™‚ï¼Œä¸æ¨™è¨˜å¡ç‰‡ç‚ºå·²ä½¿ç”¨ï¼Œåªç§»é™¤ selected æ¨™è¨˜
            gameState.playerTeam.forEach(card => {
                if (card.originalIndex !== undefined) {
                    gameState.selectedCards.delete(card.originalIndex);
                }
            });
            updateCardGrid();

            gameState.isBattleActive = true;
            gameState.currentTurn = 0;
            
            generateEnemyTeam();
            updateBattleDisplay();
            
            addLogEntry('ç³»çµ±', 'ğŸ¯ æˆ°é¬¥é–‹å§‹ï¼');
            await new Promise(resolve => setTimeout(resolve, 400));
            addLogEntry('ç³»çµ±', `ğŸ‘¹ æ•µäººæ•¸é‡ï¼š${gameState.enemyTeam.length}ï¼Œç©å®¶éšŠä¼ï¼š${gameState.playerTeam.length}äºº`);
            await new Promise(resolve => setTimeout(resolve, 400));
            addLogEntry('ç³»çµ±', 'ğŸ’ª æº–å‚™å¥½è¿æ¥æŒ‘æˆ°äº†å—ï¼Ÿ');
            
            // é–‹å§‹æ‰‹å‹•æˆ°é¬¥
            startManualBattle();
        }

        // é–‹å§‹æ‰‹å‹•æˆ°é¬¥
        function startManualBattle() {
            // é˜²å‘†åˆ¤æ–·ï¼šå¦‚æœæ²’æœ‰æ•µäººéšŠä¼ï¼Œä¸å…è¨±é–‹å§‹æ‰‹å‹•æˆ°é¬¥
            if (!gameState.enemyTeam || gameState.enemyTeam.length === 0) {
                addLogEntry('ç³»çµ±', 'âš ï¸ è«‹å…ˆé–‹å§‹æˆ°é¬¥ï¼');
                return;
            }
            
            // é˜²å‘†åˆ¤æ–·ï¼šå¦‚æœæˆ°é¬¥é‚„æ²’é–‹å§‹ï¼Œä¸å…è¨±é–‹å§‹æ‰‹å‹•æˆ°é¬¥
            if (!gameState.isBattleActive) {
                addLogEntry('ç³»çµ±', 'âš ï¸ è«‹å…ˆé–‹å§‹æˆ°é¬¥ï¼');
                return;
            }
            
            isManualBattle = true;
            currentAttacker = 0; // ç©å®¶å…ˆæ‰‹
            currentPlayerIndex = 0;
            currentEnemyIndex = 0;
            selectedEnemyIndex = -1;
            document.getElementById('manual-controls').style.display = 'block';
            addLogEntry('system', 'ğŸ¯ æ‰‹å‹•æˆ°é¬¥é–‹å§‹ï¼ç©å®¶å…ˆæ‰‹');
            updateManualControls();
        }

        // æ›´æ–°æ‰‹å‹•æˆ°é¬¥æ§åˆ¶ç•Œé¢
        function updateManualControls() {
            // æ¸›å°‘æ‰€æœ‰ç©å®¶å¡ç‰‡çš„æŠ€èƒ½å†·å»
            gameState.playerTeam.forEach(card => {
                if (card.skill && card.skill.currentCooldown > 0) {
                    card.skill.currentCooldown--;
                }
            });

            const turnInfo = document.getElementById('current-turn-info');
            const attackBtn = document.getElementById('attack-btn');
            const skillBtn = document.getElementById('skill-btn');
            const enemySelection = document.getElementById('enemy-selection');
            const enemyTargets = document.getElementById('enemy-targets');
            
            // æª¢æŸ¥æˆ°é¬¥çµæœ
            if (gameState.enemyTeam.length === 0 || gameState.playerTeam.length === 0) {
                checkBattleResult();
                return;
            }
            
            if (currentAttacker === 0) {
                // ç©å®¶å›åˆ
                const player = gameState.playerTeam[currentPlayerIndex];
                turnInfo.textContent = `ç©å®¶å›åˆï¼š${player.zh} (è¡€é‡: ${Math.round(player.hp)})`;
                
                // æª¢æŸ¥æ˜¯å¦æœ‰æ•µäººå¯æ”»æ“Š
                if (gameState.enemyTeam.length > 0) {
                    attackBtn.disabled = false;
                    skillBtn.disabled = player.skill.currentCooldown > 0;
                    
                    console.log('ç©å®¶å›åˆï¼Œæº–å‚™é¡¯ç¤ºæ•µäººé¸æ“‡ç•Œé¢');
                    // é¡¯ç¤ºæ•µäººé¸æ“‡ç•Œé¢
                    showEnemyTargets();
                } else {
                    attackBtn.disabled = true;
                    skillBtn.disabled = true;
                    enemySelection.style.display = 'none';
                }
                
                skillBtn.textContent = `æŠ€èƒ½ (${player.skill.name})`;
            } else {
                // æ•µäººå›åˆ
                const enemy = gameState.enemyTeam[currentEnemyIndex];
                turnInfo.textContent = `æ•µäººå›åˆï¼š${enemy.zh} (è¡€é‡: ${Math.round(enemy.hp)})`;
                attackBtn.disabled = true;
                skillBtn.disabled = true;
                enemySelection.style.display = 'none';
                // æ•µäººè‡ªå‹•æ”»æ“Š
                setTimeout(() => {
                    performEnemyAttack();
                }, 1000);
            }
        }

        // é¡¯ç¤ºæ•µäººç›®æ¨™é¸æ“‡
        function showEnemyTargets() {
            const enemySelection = document.getElementById('enemy-selection');
            const enemyTargets = document.getElementById('enemy-targets');
            
            console.log('showEnemyTargets è¢«èª¿ç”¨ï¼Œæ•µäººæ•¸é‡:', gameState.enemyTeam.length);
            
            // å¦‚æœåªå‰©ä¸€å€‹æ•µäººï¼Œè‡ªå‹•é¸æ“‡ä¸¦éš±è—é¸æ“‡ç•Œé¢
            if (gameState.enemyTeam.length === 1) {
                selectedEnemyIndex = 0;
                enemySelection.style.display = 'none';
                addLogEntry('system', 'ğŸ¯ åªå‰©ä¸€å€‹æ•µäººï¼Œè‡ªå‹•é¸æ“‡ç›®æ¨™');
                return;
            }
            
            // å¦‚æœæœ‰å¤šå€‹æ•µäººï¼Œé¡¯ç¤ºé¸æ“‡ç•Œé¢
            if (gameState.enemyTeam.length > 1) {
                enemySelection.style.display = 'block';
                enemyTargets.innerHTML = '';
                
                gameState.enemyTeam.forEach((enemy, index) => {
                    const targetBtn = document.createElement('button');
                    targetBtn.className = 'battle-btn';
                    targetBtn.style.cssText = `
                        background: linear-gradient(45deg, #ff4757, #ff6b6b);
                        padding: 8px 12px;
                        font-size: 0.8rem;
                        min-width: 80px;
                    `;
                    targetBtn.textContent = `${enemy.zh} (${Math.round(enemy.hp)}HP)`;
                    targetBtn.onclick = () => selectEnemyTarget(index);
                    
                    // é«˜äº®é¸ä¸­çš„ç›®æ¨™
                    if (selectedEnemyIndex === index) {
                        targetBtn.style.background = 'linear-gradient(45deg, #ffd700, #ffed4e)';
                        targetBtn.style.color = '#000';
                    }
                    
                    enemyTargets.appendChild(targetBtn);
                });
                console.log('å·²é¡¯ç¤ºæ•µäººé¸æ“‡ç•Œé¢ï¼Œæ•µäººæ•¸é‡:', gameState.enemyTeam.length);
            }
        }

        // é¸æ“‡æ•µäººç›®æ¨™
        function selectEnemyTarget(index) {
            console.log('é¸æ“‡æ•µäººç›®æ¨™:', index, 'æ•µäººåç¨±:', gameState.enemyTeam[index]?.zh);
            selectedEnemyIndex = index;
            showEnemyTargets(); // é‡æ–°é¡¯ç¤ºä»¥æ›´æ–°é«˜äº®
        }

        // åˆ‡æ›åˆ°æ•µäººå›åˆ
        async function switchToEnemyTurn() {
            currentAttacker = 1;
            selectedEnemyIndex = -1;
            document.getElementById('enemy-selection').style.display = 'none';
            
            addLogEntry('system', 'ğŸ”„ åˆ‡æ›åˆ°æ•µäººå›åˆ');
            await new Promise(resolve => setTimeout(resolve, 500));
            
            updateManualControls();
        }

        // åˆ‡æ›åˆ°ç©å®¶å›åˆ
        async function switchToPlayerTurn() {
            currentAttacker = 0;
            // æ¯å›åˆéƒ½è¦é‡æ–°é¸æ“‡
            selectedEnemyIndex = -1;
            // ç§»å‹•åˆ°ä¸‹ä¸€å€‹ç©å®¶å¡ç‰‡
            currentPlayerIndex = (currentPlayerIndex + 1) % gameState.playerTeam.length;
            // ç§»å‹•åˆ°ä¸‹ä¸€å€‹æ•µäººå¡ç‰‡
            currentEnemyIndex = (currentEnemyIndex + 1) % gameState.enemyTeam.length;
            addLogEntry('system', 'ğŸ”„ åˆ‡æ›åˆ°ç©å®¶å›åˆ');
            await new Promise(resolve => setTimeout(resolve, 500));
            updateManualControls();
        }

        // åŸ·è¡Œæ•µäººæ”»æ“Š
        async function performEnemyAttack() {
            if (gameState.enemyTeam.length > 0 && gameState.playerTeam.length > 0) {
                // åªè®“ç¬¬ä¸€å€‹æ•µäººæ”»æ“Š
                const enemy = gameState.enemyTeam[0];
                const targetIndex = Math.floor(Math.random() * gameState.playerTeam.length);
                const player = gameState.playerTeam[targetIndex];
                
                // æ•µäººæ”»æ“Šæè¿°
                addLogEntry('enemy', `ğŸ‘¹ ${enemy.zh} ç™¼å‡ºå¨è„…çš„å’†å“®ï¼`);
                await new Promise(resolve => setTimeout(resolve, 600));
                
                addLogEntry('enemy', `âš”ï¸ ${enemy.zh} å‘ ${player.zh} ç™¼å‹•æ”»æ“Šï¼`);
                await new Promise(resolve => setTimeout(resolve, 500));
                
                const damage = Math.floor((enemy.attack || 40) * 0.8);
                
                // åŸ·è¡Œæ”»æ“Šå‹•ç•«
                await animateAttack(enemy, player, damage, false);
                
                player.hp -= damage;
                addLogEntry('enemy', `ğŸ’¥ ${enemy.zh} å° ${player.zh} é€ æˆ ${damage} é»å‚·å®³ï¼`);
                // æ’­æ”¾è¢«æ”»æ“ŠéŸ³æ•ˆ
                playWrongSound();
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // æª¢æŸ¥ç©å®¶æ˜¯å¦è¢«æ“Šæ•—
                if (player.hp <= 0) {
                    addLogEntry('player', `ğŸ’€ ${player.zh} è¢«æ“Šæ•—äº†ï¼`);
                    await animateDefeat(player, true);
                    handleDefeatedCard(player, true);
                    gameState.playerTeam.splice(targetIndex, 1);
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
                
                updateBattleDisplay();
                
                // åˆ‡æ›åˆ°ç©å®¶å›åˆ
                await switchToPlayerTurn();
                
            }
        }

        // ç©å®¶æ”»æ“Š
        async function performPlayerAttack() {
            if (isAnimating) return; // é˜²æ­¢å‹•ç•«æœŸé–“é‡è¤‡é»æ“Š
            if (currentPlayerIndex < gameState.playerTeam.length && gameState.enemyTeam.length > 0) {
                // åªå‰©ä¸€å€‹æ•µäººè‡ªå‹•é¸
                if (selectedEnemyIndex < 0 && gameState.enemyTeam.length === 1) {
                    selectedEnemyIndex = 0;
                }
                if (selectedEnemyIndex < 0) {
                    addLogEntry('system', 'âš ï¸ è«‹å…ˆé¸æ“‡æ”»æ“Šç›®æ¨™ï¼');
                    return;
                }
                console.log('ç©å®¶æ”»æ“Šæª¢æŸ¥ - é¸æ“‡çš„æ•µäººç´¢å¼•:', selectedEnemyIndex, 'æ•µäººæ•¸é‡:', gameState.enemyTeam.length);
                
                // å¦‚æœæ²’æœ‰é¸æ“‡ç›®æ¨™ä½†åªå‰©ä¸€å€‹æ•µäººï¼Œè‡ªå‹•é¸æ“‡
                if (selectedEnemyIndex < 0 && gameState.enemyTeam.length === 1) {
                    selectedEnemyIndex = 0;
                    console.log('è‡ªå‹•é¸æ“‡æœ€å¾Œä¸€å€‹æ•µäºº');
                }
                
                if (selectedEnemyIndex >= 0) {
                    console.log('é–‹å§‹æ”»æ“Šæ•µäºº:', gameState.enemyTeam[selectedEnemyIndex]?.zh);
                    const player = gameState.playerTeam[currentPlayerIndex];
                    const enemy = gameState.enemyTeam[selectedEnemyIndex];
                    
                    // æª¢æŸ¥æ˜¯å¦æš´æ“Š
                    const isCritical = Math.random() < 0.15; // 15%æš´æ“Šç‡
                    const baseDamage = player.attack || 50;
                    const damage = isCritical ? Math.floor(baseDamage * 1.5) : baseDamage;
                    
                    // æˆ°é¬¥æè¿°
                    let battleDesc = '';
                    if (isCritical) {
                        battleDesc = `ğŸ’¥ ${player.zh} ç™¼å‹•æš´æ“Šæ”»æ“Šï¼`;
                        addLogEntry('player', battleDesc);
                        await new Promise(resolve => setTimeout(resolve, 800));
                    }
                    
                    battleDesc = `âš”ï¸ ${player.zh} æ®èˆæ­¦å™¨æ”»æ“Š ${enemy.zh}`;
                    addLogEntry('player', battleDesc);
                    await new Promise(resolve => setTimeout(resolve, 600));
                    
                    // åŸ·è¡Œæ”»æ“Šå‹•ç•«
                    await animateAttack(player, enemy, damage, false);
                    // æ’­æ”¾æ”»æ“ŠéŸ³æ•ˆ
                    playAttackSound();
                    
                    enemy.hp -= damage;
                    
                    // å‚·å®³æè¿°
                    const damageDesc = isCritical ? 
                        `ğŸ’¥ æš´æ“Šï¼é€ æˆ ${damage} é»å·¨å¤§å‚·å®³ï¼` : 
                        `ğŸ’¥ é€ æˆ ${damage} é»å‚·å®³`;
                    addLogEntry('player', damageDesc);
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // æª¢æŸ¥æ•µäººæ˜¯å¦è¢«æ“Šæ•—
                    if (enemy.hp <= 0) {
                        addLogEntry('enemy', `ğŸ’€ ${enemy.zh} è¢«æ“Šæ•—äº†ï¼`);
                        await animateDefeat(enemy, false);
                        gameState.enemyTeam.splice(selectedEnemyIndex, 1);
                        await new Promise(resolve => setTimeout(resolve, 300));
                    }
                    
                    updateBattleDisplay();
                    selectedEnemyIndex = -1; // é‡ç½®é¸æ“‡
                    
                    // åˆ‡æ›åˆ°æ•µäººå›åˆ
                    await switchToEnemyTurn();
                } else {
                    addLogEntry('system', 'âš ï¸ è«‹å…ˆé¸æ“‡æ”»æ“Šç›®æ¨™ï¼');
                }
            } else if (selectedEnemyIndex < 0) {
                addLogEntry('system', 'âš ï¸ è«‹å…ˆé¸æ“‡æ”»æ“Šç›®æ¨™ï¼');
            }
        }

        // ç©å®¶ä½¿ç”¨æŠ€èƒ½
        async function performPlayerSkill() {
            if (isAnimating) return; // é˜²æ­¢å‹•ç•«æœŸé–“é‡è¤‡é»æ“Š

            if (currentPlayerIndex < gameState.playerTeam.length && gameState.enemyTeam.length > 0) {
                // å¦‚æœæ²’æœ‰é¸æ“‡ç›®æ¨™ä½†åªå‰©ä¸€å€‹æ•µäººï¼Œè‡ªå‹•é¸æ“‡
                if (selectedEnemyIndex < 0 && gameState.enemyTeam.length === 1) {
                    selectedEnemyIndex = 0;
                }
                
                if (selectedEnemyIndex >= 0) {
                    const player = gameState.playerTeam[currentPlayerIndex];
                    const enemy = gameState.enemyTeam[selectedEnemyIndex];
                    
                    const baseDamage = player.attack || 50;
                    const skillDamage = Math.floor(baseDamage * player.skill.damage);
                    
                    // æŠ€èƒ½ç™¼å‹•æè¿°
                    addLogEntry('player', `ğŸŒŸ ${player.zh} é–‹å§‹å‡èšåŠ›é‡...`);
                    await new Promise(resolve => setTimeout(resolve, 800));
                    
                    addLogEntry('player', `âœ¨ ç™¼å‹•æŠ€èƒ½ã€Œ${player.skill.name}ã€ï¼`);
                    await new Promise(resolve => setTimeout(resolve, 600));
                    
                    // åŸ·è¡ŒæŠ€èƒ½å‹•ç•«
                    await animateAttack(player, enemy, skillDamage, true);
                    // æ’­æ”¾æŠ€èƒ½éŸ³æ•ˆ
                    playSkillSound();
                    
                    enemy.hp -= skillDamage;
                    
                    addLogEntry('player', `ğŸ’« æŠ€èƒ½ã€Œ${player.skill.name}ã€é€ æˆ ${skillDamage} é»å‚·å®³ï¼`);
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // è¨­ç½®æŠ€èƒ½å†·å»
                    player.skill.currentCooldown = player.skill.cooldown;
                    addLogEntry('system', `â° ${player.zh} çš„æŠ€èƒ½é€²å…¥å†·å»æœŸ`);
                    await new Promise(resolve => setTimeout(resolve, 300));
                    
                    // æª¢æŸ¥æ•µäººæ˜¯å¦è¢«æ“Šæ•—
                    if (enemy.hp <= 0) {
                        addLogEntry('enemy', `ğŸ’€ ${enemy.zh} è¢«æŠ€èƒ½æ“Šæ•—äº†ï¼`);
                        await animateDefeat(enemy, false);
                        gameState.enemyTeam.splice(selectedEnemyIndex, 1);
                        await new Promise(resolve => setTimeout(resolve, 300));
                    }
                    
                    updateBattleDisplay();
                    selectedEnemyIndex = -1; // é‡ç½®é¸æ“‡
                    
                    // åˆ‡æ›åˆ°æ•µäººå›åˆ
                    await switchToEnemyTurn();
                } else {
                    addLogEntry('system', 'âš ï¸ è«‹å…ˆé¸æ“‡æ”»æ“Šç›®æ¨™ï¼');
                }
            } else if (selectedEnemyIndex < 0) {
                addLogEntry('system', 'âš ï¸ è«‹å…ˆé¸æ“‡æ”»æ“Šç›®æ¨™ï¼');
            }
        }

        // æª¢æŸ¥æˆ°é¬¥çµæœ
        async function checkBattleResult() {
            if (gameState.enemyTeam.length === 0) {
                addLogEntry('system', 'ğŸ‰ æˆ°é¬¥å‹åˆ©ï¼æ‰€æœ‰æ•µäººéƒ½è¢«æ“Šæ•—äº†ï¼');
                await new Promise(resolve => setTimeout(resolve, 800));
                addLogEntry('system', 'ğŸŒŸ ä½ çš„éšŠä¼å±•ç¾äº†ç„¡èˆ‡å€«æ¯”çš„å¯¦åŠ›ï¼');
                await new Promise(resolve => setTimeout(resolve, 600));
                console.log('æˆ°é¬¥å‹åˆ©ï¼Œæº–å‚™çµ¦äºˆ20é¡†æ˜Ÿæ˜Ÿçå‹µ');
                addStarsToBattle(20);
                console.log('å·²çµ¦äºˆ20é¡†æ˜Ÿæ˜Ÿçå‹µï¼Œç•¶å‰æ˜Ÿæ˜Ÿ:', getCurrentStars());
                addLogEntry('system', 'ğŸ’ ç²å¾—æ˜Ÿæ˜Ÿçå‹µï¼š20é¡†ï¼');
                await new Promise(resolve => setTimeout(resolve, 500));
                addLogEntry('system', 'ğŸ† æ­å–œä½ è´å¾—äº†é€™å ´æ¿€çƒˆçš„æˆ°é¬¥ï¼');
                endBattle();
                return;
            }
            
            if (gameState.playerTeam.length === 0) {
                addLogEntry('system', 'ğŸ’” æˆ°é¬¥å¤±æ•—ï¼æ‰€æœ‰ç©å®¶éƒ½è¢«æ“Šæ•—äº†ï¼');
                await new Promise(resolve => setTimeout(resolve, 800));
                addLogEntry('system', 'ğŸ˜” æ•µäººå¤ªå¼·å¤§äº†ï¼Œä¸‹æ¬¡å†ä¾†æŒ‘æˆ°å§ï¼');
                await new Promise(resolve => setTimeout(resolve, 600));
                addLogEntry('system', 'ğŸ’ª ä¸è¦æ°£é¤’ï¼Œå¼·åŒ–ä½ çš„éšŠä¼å¾Œå†æˆ°ï¼');
                endBattle();
                return;
            }
        }

        // çµæŸæˆ°é¬¥
        function endBattle() {
            gameState.isBattleActive = false;
            isManualBattle = false;
            document.getElementById('manual-controls').style.display = 'none';
            updateCardGrid();
        }

        // è™•ç†è¢«æ“Šæ•—çš„å¡ç‰‡
        async function handleDefeatedCard(card, isPlayer) {
            if (isPlayer && card.originalIndex !== undefined) {
                gameState.usedCards.add(card.originalIndex);
                saveUsedCards();
                await animateDefeat(card, isPlayer); // æ·»åŠ æ“Šæ•—å‹•ç•«
            }
        }

        // é‡ç½®æˆ°é¬¥
        function resetBattle() {
            gameState.isBattleActive = false;
            isManualBattle = false;
            gameState.enemyTeam = [];
            gameState.currentTurn = 0;
            document.getElementById('manual-controls').style.display = 'none';
            selectedEnemyIndex = -1;
            document.getElementById('enemy-selection').style.display = 'none';
            
            // æ¢å¾©ç©å®¶éšŠä¼è¡€é‡
            gameState.playerTeam.forEach(card => {
                card.hp = card.hp || 100;
                // é‡ç½®æŠ€èƒ½å†·å»
                if (card.skill) {
                    card.skill.currentCooldown = 0;
                }
            });
            
            updateBattleDisplay();
            addLogEntry('ç³»çµ±', 'æˆ°é¬¥å·²é‡ç½®');
        }

        // æ·»åŠ æ—¥èªŒæ¢ç›®
        function addLogEntry(type, message) {
            const battleLog = document.getElementById('battle-log');
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry ${type}`;
            logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            battleLog.appendChild(logEntry);
            battleLog.scrollTop = battleLog.scrollHeight;
        }

        // è¨­ç½®äº‹ä»¶ç›£è½å™¨
        function setupEventListeners() {
            document.getElementById('start-battle').addEventListener('click', startBattle);
            document.getElementById('manual-battle').addEventListener('click', startManualBattle);
            document.getElementById('attack-btn').addEventListener('click', performPlayerAttack);
            document.getElementById('skill-btn').addEventListener('click', performPlayerSkill);
            document.getElementById('skip-btn').addEventListener('click', () => {
                currentPlayerIndex++;
                updateManualControls();
            });
            document.getElementById('back-to-home').addEventListener('click', () => {
                window.location.href = 'index.html'; // è·³è½‰åˆ°é¦–é 
            });
        }

        // é é¢è¼‰å…¥å®Œæˆå¾Œåˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', () => {
            console.log('é é¢è¼‰å…¥å®Œæˆï¼Œé–‹å§‹åˆå§‹åŒ–...');
            initGame();
        });

        // é¡¯ç¤ºå¡ç‰‡æ”¾å¤§é è¦½
        function showCardPreview(card) {
            const modal = document.getElementById('card-preview-modal');
            const mediaDiv = document.getElementById('card-preview-media');
            const titleDiv = document.getElementById('card-preview-title');
            const statsDiv = document.getElementById('card-preview-stats');
            // æ¸…ç©º
            mediaDiv.innerHTML = '';
            titleDiv.textContent = card.zh || '';
            statsDiv.innerHTML = `<span style='color:#ff6b6b;'>æ”»:${card.attack||0}</span>ã€€<span style='color:#4ecdc4;'>é˜²:${card.defense||0}</span>ã€€<span style='color:#45b7d1;'>è¡€:${card.hp||0}</span>`;
            // æ”¾å¤§å…§å®¹
            if (card.image && card.image.endsWith('.mp4')) {
                mediaDiv.innerHTML = `<video src="${card.image}" style="width:160px;height:220px;object-fit:cover;border-radius:12px;box-shadow:0 0 12px #00ffff99;" muted autoplay loop playsinline></video>`;
            } else {
                const imgSrc = card.image || 'img/card_back.jpeg';
                mediaDiv.innerHTML = `<img src="${imgSrc}" alt="${card.zh}" style="width:160px;height:220px;object-fit:cover;border-radius:12px;box-shadow:0 0 12px #00ffff99;">`;
            }
            modal.style.display = 'flex';
        }

        // é—œé–‰é è¦½
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('close-card-preview').onclick = () => {
                document.getElementById('card-preview-modal').style.display = 'none';
            };
            document.getElementById('card-preview-modal').onclick = (e) => {
                if (e.target === document.getElementById('card-preview-modal')) {
                    document.getElementById('card-preview-modal').style.display = 'none';
                }
            };
        });
    </script>
</body>
</html>
